<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>细说集合类之Collection部分</title>
      <link href="/2023/06/24/%E7%BB%86%E8%AF%B4%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>/2023/06/24/%E7%BB%86%E8%AF%B4%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>集合类是十分常用的一系列类，主体分为Map为根的实现类和Collection为根的实现类</p><span id="more"></span><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>咱们先以最常见的Collection说起，先看文档(机翻)</p><blockquote><p>集合层次结构中的根接口。<br>集合表示一组对象，称为其元素。<br>某些集合允许重复元素，而其他集合则不允许。有些是有序的，有些是无序的。<br>JDK 不提供此接口的任何直接实现：它提供了更具体的子接口（如 Set 和 List）的实现。<br>此接口通常用于传递集合，并在需要最大通用性的地方操作它们。</p></blockquote><p><em>由于集合类家族庞大，我们尽量以介绍接口为主，具体实现以重点为介绍。</em><br>根据官方介绍，可以看见Collection接口是用来粗略规定哪些是可以归纳进集合体系的，并且可以用于粗略操作和传递的。</p><blockquote><p>Collection接口下，整体设计思想为模板方法设计模式，<br>在这种模式中，定义一个操作的算法框架，并将一些步骤延迟到子类中实现。模板方法使得子类可以在不改变算法框架的情况下重新定义算法中的某些步骤。<br>在Java集合类中，接口定义了一些公共方法，而抽象类则提供了一些默认实现，具体的实现类可以根据需要选择性地实现这些方法。<br>例如，AbstractList类提供了一些通用的方法（如get、set、add、remove等），而具体的List实现类（如ArrayList、LinkedList等）只需要实现其中一些方法即可，其余方法则可以继承自AbstractList类。<br>这种模式的优点是可以避免代码重复，提高代码复用性，并且能够方便地扩展和修改代码。<br>看起来有些不知所以然？那就慢慢读下去，看到具体如何做，就一目了然啦~</p></blockquote><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>基本规定了，增删改查，以及一些其他的方法，具体如下：<br><strong>增：</strong></p><ul><li>add(E e)</li><li>确保此集合包含指定的元素（可选操作）。</li><li>boolean addAll(Collection&lt;? extends E&gt; c)</li><li>将指定集合中的所有元素添加到此集合（可选操作）。</li></ul><p><strong>删：</strong></p><ul><li>void clear()</li><li>从此集合中删除所有元素（可选操作）。</li><li>boolean remove(Object o)</li><li>从该集合中删除指定元素的单个实例（如果存在）（可选操作）。</li><li>boolean removeAll(Collection&lt;?&gt; c)</li><li>删除指定集合中包含的所有此集合的元素（可选操作）。</li><li>default boolean removeIf(Predicate&lt;? super E&gt; filter)</li><li>删除满足给定谓词的此集合的所有元素。</li><li>boolean retainAll(Collection&lt;?&gt; c)</li><li>仅保留此集合中包含在指定集合中的元素（可选操作）。</li></ul><p><strong>改（没有改元素，只有改成）：</strong><br>分为改成Array(数组),Stream(流),Spliterator(迭代器)</p><ul><li>Object[] toArray()</li><li>返回一个包含此集合中所有元素的数组。</li><li>T[]    toArray(T[] a)</li><li>返回包含此集合中所有元素的数组;返回的数组的运行时类型是指定数组的运行时类型。</li><li>default Stream<E>    stream()</li><li>返回以此集合作为源的顺序 Stream。</li><li>default Stream<E>    parallelStream()</li><li>返回可能并行的 Stream与此集合作为其来源。</li><li>Iterator<E>    iterator()</li><li>返回此集合中的元素的迭代器。</li><li>default Spliterator<E>    spliterator()</li><li>创建一个Spliterator在这个集合中的元素。</li></ul><p><strong>查：</strong><br>可以查的东西可太多了，例如查一查是否包含某个值或某些值，是否为空，长度为多少，还有重写了Object的equals和hashCode方法，可以用来比较两个集合是否相等</p><ul><li>boolean contains(Object o)</li><li>如果此集合包含指定的元素，则返回 true 。</li><li>boolean containsAll(Collection&lt;?&gt; c)</li><li>如果此集合包含指定 集合中的所有元素，则返回true。</li><li>boolean equals(Object o)</li><li>将指定的对象与此集合进行比较以获得相等性。</li><li>int hashCode()</li><li>返回此集合的哈希码值。</li><li>boolean isEmpty()</li><li>如果此集合不包含元素，则返回 true 。</li><li>int size()</li><li>返回此集合中的元素数。</li></ul><p><strong>注意，这里并没有提供可以查到具体某个元素的方法，只是粗略查询，但有具体精准的删除方法</strong></p><p>每个集合类都需要实现上面这些方法，每个集合类都有上面这些方法，方法虽然繁杂，但为后续使用提供便利。<br>但jdk并没有直接实现Collection接口，而是提供了更具体的实现接口，Set，List和Queue，同时还提供了AbstractCollection，用来给程序员进行快速实现。</p><h3 id="分析集合类构成"><a href="#分析集合类构成" class="headerlink" title="分析集合类构成"></a>分析集合类构成</h3><p>jdk的集合类庞大，看一下图：<br><img src="/../pic/img.png" alt="img.png"><br>先别急着头大😫，我们庖丁解牛，一步一步来。 根据图，可以看到主要分为三大接口List,Set,Queue。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//为了快速获取这个接口独特在哪里，写个函数查询不同方法很重要:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 本方法用于不同类的方法继承比较，来更好学习某类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> son 待测类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> father 父类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mapper 通过比较什么，而判断是否重复</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sout 输出什么</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">soutDistinct</span><span class="hljs-params">(Class&lt;?&gt; son, Class&lt;?&gt; father,</span><br><span class="hljs-params">                                   Function&lt;? <span class="hljs-built_in">super</span> Method, ? extends Object&gt; mapper,</span><br><span class="hljs-params">                                   Function&lt;? <span class="hljs-built_in">super</span> Method, ? extends Object&gt;... sout)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!father.isAssignableFrom(son)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;待比较类无继承关系&quot;</span>);<br>        &#125;<br><br>        Method[] fatherMethods = father.getMethods();<br>        <span class="hljs-keyword">if</span> (fatherMethods.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;父类无方法&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!Arrays.stream(sout).findAny().isPresent()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;输出类型不全&quot;</span>);<br>        &#125;<br><br>        List&lt;Object&gt; collect = Arrays.stream(fatherMethods).map(mapper).collect(Collectors.toList());<br>        Arrays.stream(son.getMethods())<br>                .distinct()<br>                .filter(i -&gt; !collect.contains(mapper.apply(i)))<br>                .forEach(i -&gt; &#123;<br>                    Arrays.stream(sout).forEach(j -&gt; System.out.print(j.apply(i) + <span class="hljs-string">&quot; &quot;</span>));<br>                    System.out.println();<br>                &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面这个方法，可以粗略得知：<br>List定位为有序集合（序列），可以通过索引访问，可以有重复元素，提供的方法也是以可索引访问而展开的方法。<br>Set定位为无重复集合，并没有扩展新的方法，而是改了约定。<br>Queue定位为队列，提供了队列操作的基本方法。</p><p><strong>细心的朋友是否还记得还有个靠前的抽象类AbstractCollection，通过上面的方法，可以知道它扩展了作为类的基本操作。</strong><br><strong>注意这便是模板方法设计模式，后续List、Set、Queue也是类似使用方法</strong></p><blockquote><p>q: 那如何通过AbstractCollection来实现自己想要的集合类呢？<br>a: 为了实现一个不可修改的集合，程序员只需要扩展这个类并提供iterator和size方法的实现。 （<br>iterator方法返回的迭代器必须实现hasNext和next ）<br>要实现可修改的集合，程序员必须另外覆盖此类的add方法（否则将抛出UnsupportedOperationException<br>），并且由iterator方法返回的迭代器必须另外实现其remove方法。</p></blockquote><p>后续的AbstractXX类都是类似作用，通过可选择性实现某些方法，来实现自己想要的集合类</p><p>在大致分析完Collection接口的直接继承接口后，我们开始具体分析吧~</p><h3 id="分析List"><a href="#分析List" class="headerlink" title="分析List"></a>分析List</h3><p>List接口继承Collection接口，提供了一些新的方法，如下:<br>大致在改和查上有所体现</p><ul><li><p>get</p></li><li><p>根据索引获取值</p></li><li><p>indexOf</p></li><li><p>查看该元素首个位置</p></li><li><p>lastIndexOf</p></li><li><p>查看该元素最后的位置<br>可以通过索引找到元素，也可以通过元素找到索引</p></li><li><p>replaceAll</p></li><li><p>替换掉所有符合类型的元素</p></li><li><p>set</p></li><li><p>设置某元素<br>替换某些元素</p></li><li><p>subList</p></li><li><p>返回指定范围的视图</p></li><li><p>listIterator</p></li><li><p>返回列表迭代器（之前Collection也有规定其他样式的迭代器嗷）</p></li><li><p>sort</p></li><li><p>排序<br>改成或返回新的形式</p></li></ul><p>通过观察类图可知，其主要实现的主要类为AbstractList，其他类继承该类。</p><blockquote><p>q: AbstractList是什么呢？<br>a: AbstractList是Java集合框架中的一个抽象类，实现了List接口并提供了一些通用的方法实现。它的主要作用是为具体的List实现类提供一个通用的模板，使得开发者可以更方便地实现自己的List类。<br>但注意由于AbstractList没有自己的数据，所以相关数据的操作，它是抛出异常的，当然这样算是实现了方法，某种意义上，和AbstractCollection一样可以关闭了某些方法使用<br>q：那如何通过AbstractList来实现自己的List类呢？<br>a: 要实现一个不可修改的列表，程序员只需要扩展这个类并提供get(int)和size()方法的实现。<br>要实现可修改的列表，程序员必须另外覆盖set(int, E)方法（否则会抛出一个UnsupportedOperationException ）。<br>如果列表是可变大小，则程序员必须另外覆盖add(int, E)和remove(int)方法。</p></blockquote><p>观察AbstractList，它有个关键字段modCount。<br>作用是记录被结构修改的次数，就是每一次操作记录一下，配合迭代器使用，可以在迭代器进行完后，检查是否和迭代器计数比对，来判断是否操作正常（考虑到了并发）。<br><em>形象的说，就是古代账房中的每次记录，最终需要考核来判断是不是中间算账的时候出现问题。</em></p><p>注意AbstractList的关键是如何拓展，因为后续类也是职责也是由此而生的：<br>实现不可修改的列表：提供get(int),size()<br>实现可修改的列表：提供get(int),size(),set(int, E)<br>实现可变大小：提供get(int),size(),add(int, E, remove(int)</p><h4 id="非AbstractList一族"><a href="#非AbstractList一族" class="headerlink" title="非AbstractList一族"></a>非AbstractList一族</h4><p>那不继承AbstractList的有哪些类？发现有SubList，RandomAccessSubList</p><blockquote><p>先看看机器人怎么说？<br>SubList是Java集合框架中的一个类，它是List接口的一个实现类，用于表示原List中的一个子列表。SubList可以看作是原List的一个视图，它提供了一种方便的方式来访问原List中的一部分元素。</p></blockquote><p>SubList的作用在于，它允许开发者对原List中的一个子列表进行操作，包括添加、删除、修改和遍历等。这种操作会直接影响原List中相应的元素，因为SubList只是原List的一个视图，它与原List共享相同的数据存储结构，对SubList的操作会直接反映在原List中。</p><blockquote><p>使用SubList的好处在于，它提供了一种方便的方式来对List中的一部分元素进行操作，避免了使用循环或索引访问等繁琐的操作。另外，SubList还可以用于将一个List分割成多个部分进行处理，使得代码更加可读、可维护。<br>需要注意的是，对SubList的操作可能会影响原List的结构，因此在使用SubList时需要格外小心，确保操作的正确性。此外，SubList并不是线程安全的，因此在多线程环境下使用时需要进行同步处理。</p></blockquote><p>这下明白了，为什么直接new不了，它是用于对子列表的操作的列表，能new出来就有怪了。<br>由于不是特别常用，就先不继续往下分析SubList了。</p><h4 id="AbstractList一族"><a href="#AbstractList一族" class="headerlink" title="AbstractList一族"></a>AbstractList一族</h4><p>观察类图可以得知，终于到了能用的实现类了，有Vector，ArrayList和AbstractSequentialList(后续LinkList)<br>Vector和ArrayList是基于数组实现的，咱们先说Vector:</p><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p>Vector是Java集合框架中的一个类，它实现了List接口以及一些其他的接口，如Cloneable、Serializable等接口，<br>可以看作是一种可自动扩容的数组。Vector类的功能和ArrayList类类似，不同之处在于，Vector是线程安全的，支持多线程并发访问，但是在多线程环境下性能较低。<br>Vector提供了以下方法：<br>还是增删改查，同时都是相关Element</p><h5 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h5><ul><li>addElement(E obj)：在Vector的末尾添加一个元素。</li><li>insertElementAt(E obj, int index)：在Vector的指定位置插入一个元素。</li></ul><h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><ul><li>removeElement(Object obj)：移除Vector中的指定元素。</li><li>removeElementAt(int index)：移除Vector中指定位置的元素。</li></ul><h5 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h5><ul><li>setElementAt(E obj, int index)：将Vector中指定位置的元素替换为指定元素。</li></ul><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><ul><li>elementAt(int index)：返回Vector中指定位置的元素。</li><li>firstElement()：返回Vector中的第一个元素。</li><li>lastElement()：返回Vector中的最后一个元素。</li></ul><h5 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h5><ul><li>capacity()：返回Vector的容量大小。</li><li>ensureCapacity(int minCapacity)：设置Vector的容量大小，如果当前容量小于指定容量，则自动增加容量。</li><li>trimToSize()：将Vector的容量设置为当前元素数量，释放多余的空间。</li></ul><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>通过之前的函数可以发现，ArrayList并没有提供关于增删改查的方法，只是提供了一些其他操作。<br>虽然它提供的方法基本和AbstractList的方法类似，但进行了具体实现（篇幅有限，先不说它），使其线程不安全，但操作较为快速。</p><h5 id="其他操作-1"><a href="#其他操作-1" class="headerlink" title="其他操作"></a>其他操作</h5><ul><li>clone()：赋值ArrayList。</li><li>trimToSize()：将ArrayList的容量设置为当前元素数量，释放多余的空间。</li><li>ensureCapacity(int minCapacity)：设置ArrayList的容量大小，如果当前容量小于指定容量，则自动增加容量。</li></ul><p>当然在ArrayList不止有本身类方法的重写，也写了许多内部类：SubList(服务于subList)、Ltr与ListLtr(服务于获取迭代器)。</p><h5 id="AbstractSequentialList"><a href="#AbstractSequentialList" class="headerlink" title="AbstractSequentialList"></a>AbstractSequentialList</h5><blockquote><p>q: AbstractSequentialList是什么？<br>a: 先来看看官方介绍：<br>此类提供的骨干实现List界面最小化以实现此接口由“连续访问”数据存储备份所需的工作（如链接列表）。<br>对于随机访问数据（如数组），AbstractList应优先于此类。</p><p>q: 那如何通过AbstractSequentialList实现连续访问的List类呢？<br>a: 为了实现一个列表，程序员只需要扩展这个类，并提供listIterator和size方法的实现。<br>对于一个不可修改的列表，程序员只需要实现列表迭代器的hasNext，next，hasPrevious，previous和index方法。<br>对于可修改的列表，程序员应该另外实现list iterator的set方法。<br>对于可变大小的列表，程序员应该另外实现list iterator的remove和add方法。</p></blockquote><p>观察源码可以看到，AbstractSequentialList将它的方法(增add删remove改set查get)实现，并使用listIterator来实现。<br>所以我们重点是实现listIterator，相当于我们需要实现一个迭代器，并根据需求把迭代器的方法灵活调整，来灵活实现所需List</p><h3 id="分析Queue"><a href="#分析Queue" class="headerlink" title="分析Queue"></a>分析Queue</h3><p>终于分析完了List</p><p>Queue接口也是继承自Collection接口的，它表示一种队列的数据结构，支持在队列的末尾添加元素，在队列的头部移除元素，并支持查询队列的头部元素。<br>Queue接口提供了以下方法：</p><ul><li>offer</li><li>在队列的末尾添加元素，如果队列已满则返回false</li><li>poll</li><li>移除队列的头部元素，如果队列为空则返回null</li><li>element</li><li>返回队列的头部元素，如果队列为空则抛出异常</li><li>peek</li><li>返回队列的头部元素，如果队列为空则返回null</li><li>另外，Queue接口还继承了Collection接口中的一些方法，例如size、isEmpty、contains、iterator等方法，这些方法的含义与Collection接口中的含义相同。</li></ul><p>类似List，Queue也是主要依靠AbstractQueue来作为模板，来编写实现类的。</p><h4 id="AbstractQueue"><a href="#AbstractQueue" class="headerlink" title="AbstractQueue"></a>AbstractQueue</h4><p>观察源码可以看到，它把之前AbstractCollection所需的方法进行了拓展和修改，</p><blockquote><p>此类提供某些Queue操作的框架实现。当基实现不允许空元素时，此类中的实现是合适的。<br>方法 add、 和 分别基于 offer、 poll remove和 element peek，但会引发异常，而不是通过 false 或 null 返回来指示失败。</p></blockquote><p>同样的模板方法设计模式，我们只需要实现offer、poll、peek、size方法即可，之前的Collection所需方法被用offer、poll、peek来实现了。<br>我们类似之前的写作手法，先看看不使用模板方法的接口Deque</p><h5 id="非AbstractQueue一族-Deque接口"><a href="#非AbstractQueue一族-Deque接口" class="headerlink" title="非AbstractQueue一族 Deque接口"></a>非AbstractQueue一族 Deque接口</h5><p>Deque是Java集合框架中的双端队列接口，它继承了Queue接口，并提供了一系列在队列两端进行插入、删除、获取元素的方法。<br>Deque可以被实现为线程安全的或非线程安全的，具体实现类有ArrayDeque和LinkedList等。<br>以下是Deque接口中定义的常用方法：</p><h5 id="增加元素："><a href="#增加元素：" class="headerlink" title="增加元素："></a>增加元素：</h5><ul><li>addFirst(E e)：将指定元素插入Deque的开头；</li><li>addLast(E e)：将指定元素插入Deque的结尾；</li><li>offerFirst(E e)：将指定元素插入Deque的开头，如果Deque已满，则返回false；</li><li>offerLast(E e)：将指定元素插入Deque的结尾，如果Deque已满，则返回false；</li><li>push(E e)：将指定元素插入Deque的开头，相当于addFirst方法。</li></ul><h5 id="删除元素："><a href="#删除元素：" class="headerlink" title="删除元素："></a>删除元素：</h5><ul><li>removeFirst()：移除Deque的开头元素，如果Deque为空，则抛出NoSuchElementException异常；</li><li>removeLast()：移除Deque的结尾元素，如果Deque为空，则抛出NoSuchElementException异常；</li><li>pollFirst()：移除Deque的开头元素，如果Deque为空，则返回null；</li><li>pollLast()：移除Deque的结尾元素，如果Deque为空，则返回null；</li><li>pop()：移除Deque的开头元素，相当于removeFirst方法。</li></ul><h5 id="获取元素："><a href="#获取元素：" class="headerlink" title="获取元素："></a>获取元素：</h5><ul><li>getFirst()：获取Deque的开头元素，如果Deque为空，则抛出NoSuchElementException异常；</li><li>getLast()：获取Deque的结尾元素，如果Deque为空，则抛出NoSuchElementException异常；</li><li>peekFirst()：获取Deque的开头元素，如果Deque为空，则返回null；</li><li>peekLast()：获取Deque的结尾元素，如果Deque为空，则返回null；</li><li>element()：获取Deque的开头元素，相当于getFirst方法。</li></ul><h5 id="其他操作："><a href="#其他操作：" class="headerlink" title="其他操作："></a>其他操作：</h5><ul><li>removeFirstOccurrence(Object o)：移除Deque中第一次出现的指定元素；</li><li>removeLastOccurrence(Object o)：移除Deque中最后一次出现的指定元素；</li><li>descendingIterator()：返回一个反向迭代器，可以从Deque的尾部向头部迭代。</li></ul><p>需要注意的是，如果Deque是空的，调用getFirst、getLast、element等方法会抛出NoSuchElementException异常。<br>如果调用addFirst、addLast、offerFirst、offerLast等方法时，Deque已满，则会抛出IllegalStateException异常。</p><h5 id="ArrayDeque-和-LinkedList"><a href="#ArrayDeque-和-LinkedList" class="headerlink" title="ArrayDeque 和 LinkedList"></a>ArrayDeque 和 LinkedList</h5><p>那我们说一下ArrayDeque，它是Deque接口的一个实现类，它是基于数组实现的双端队列，它没有容量上限，可以根据需要自动扩容（具体自动扩容可以详细查看源码）。<br>LinkedList是Deque接口的另一个实现类，它是基于链表实现的双端队列，它没有容量上限，也可以根据需要自动扩容。</p><blockquote><p>比较一下两者</p></blockquote><ul><li>内部实现：ArrayDeque采用循环数组的形式实现，而LinkedList则采用链表的形式实现。循环数组可以更好地利用计算机内存的缓存机制，因此在插入、删除、获取元素等操作中具有更优秀的性能。而链表则可以很方便地进行元素的插入和删除操作，但是在访问元素时需要遍历整个链表，因此访问元素的性能相对较低。</li><li>内存占用：相比于ArrayDeque，LinkedList具有较大的内存占用。由于LinkedList采用链表的形式实现，需要为每个元素分配独立的内存空间。而ArrayDeque则采用一个数组存储所有元素，因此可以避免为每个元素分配独立的内存空间带来的开销。</li><li>线程安全性：ArrayDeque是非线程安全的，不支持多线程并发访问。而LinkedList则是非线程安全的，但可以通过Collections.synchronizedList方法或者使用ConcurrentLinkedDeque等线程安全的类来实现多线程并发访问。</li></ul><h4 id="AbstractQueue一族"><a href="#AbstractQueue一族" class="headerlink" title="AbstractQueue一族"></a>AbstractQueue一族</h4><p>让我们说回AbstractQueue部分，在类图中可以看到只有PriorityQueue(当然在别的地方也有继承，但在这里先不讨论)<br>继承了AbstractQueue，那让我们来分析它。</p><blockquote><p>PriorityQueue是什么呢？<br>PriorityQueue是堆结构，它可以用于对元素进行排序并快速地获取优先级最高的元素。PriorityQueue可以存储任何可比较的元素，包括基本数据类型和自定义对象。<br>PriorityQueue的实现基于二叉堆数据结构，它是一种完全二叉树，并且具有以下性质：<br>父节点的值小于或等于其子节点的值（小根堆）<br>父节点的值大于或等于其子节点的值（大根堆）<br>PriorityQueue默认采用小根堆的形式实现，也可以通过传入一个Comparator对象来修改为大根堆。<br>在PriorityQueue中，插入元素和删除元素的时间复杂度均为O(log n)，其中n为队列中元素的个数。</p></blockquote><p>观察PriorityQueue，可以发现它并没有扩展方法，类似之前的AbstractSequentialList的设计模式（模板方法）一样，并使用比较器贯穿所有方法，以此实现堆。</p><h3 id="分析Set接口"><a href="#分析Set接口" class="headerlink" title="分析Set接口"></a>分析Set接口</h3><p>前文说到Set并没有扩展新方法，而是增加了约定。</p><blockquote><p>先来看看官方定义:<br>不包含重复元素的集合。更正式地，集合不包含一对元素e1和e2，使得e1.equals(e2)，并且最多一个空元素。正如其名称所暗示的那样，这个接口模拟了数学集抽象。<br>Set接口除了继承自Collection接口的所有构造函数的合同以及add,equals和hashCode方法的合同外，还增加了其他规定。</p></blockquote><p>和前文一样，使用模板方法设计模式的AbstractSet来进行实现Set类，但是这次我们先分析不使用AbstractSet的SortedSet</p><h4 id="SortedSet接口和NavigableSet接口"><a href="#SortedSet接口和NavigableSet接口" class="headerlink" title="SortedSet接口和NavigableSet接口"></a>SortedSet接口和NavigableSet接口</h4><p>SortedSet是Java集合框架中的一种有序集合，它继承自Set接口，保证其中的元素是按照某种特定的排序方式进行排序的。<br>SortedSet中新增的方法主要是与排序有关的方法，包括：</p><ul><li>first()：返回集合中的第一个元素。</li><li>last()：返回集合中的最后一个元素。</li><li>headSet(E toElement)：返回一个子集合，其中包含小于指定元素的所有元素。</li><li>subSet(E fromElement, E toElement)：返回一个子集合，其中包含大于等于fromElement且小于toElement的所有元素。</li><li>tailSet(E fromElement)：返回一个子集合，其中包含大于等于指定元素的所有元素。</li></ul><p>很明显由于该集合有一定顺序，所以提供的方法可以只通过元素来获取一段子集合，而不需要通过索引来获取。</p><p>而我们下面要讲述的NavigableSet接口是SortedSet接口的拓展，它提供了一些导航方法，可以更灵活的对集合进行操作。</p><ul><li><p>lower(E e)：返回集合中小于指定元素的最大元素。</p></li><li><p>floor(E e)：返回集合中小于等于指定元素的最大元素。</p></li><li><p>ceiling(E e)：返回集合中大于等于指定元素的最小元素。</p></li><li><p>higher(E e)：返回集合中大于指定元素的最小元素。<br>返回指定一定范围的某个元素。</p></li><li><p>pollFirst()：返回集合中的第一个元素，并在集合中删除该元素。</p></li><li><p>pollLast()：返回集合中的最后一个元素，并在集合中删除该元素。<br>删除元素。</p></li><li><p>descendingSet()：返回集合中的逆序集合。</p></li><li><p>descendingIterator()：返回集合中的逆序迭代器。<br>返回逆序集合或逆序迭代器。</p></li></ul><p>值得注意的是NavigableSet并没有对之前Set接口进行实现，提供了扩展方法接口。</p><h4 id="AbstractSet"><a href="#AbstractSet" class="headerlink" title="AbstractSet"></a>AbstractSet</h4><blockquote><p>说回我们的AbstractSet，此类提供 Set 接口的框架实现，以最大程度地减少实现此接口所需的工作量。<br>通过扩展此类实现集合的过程与通过扩展 AbstractCollection 实现集合的过程相同，只是此类子类中的所有方法和构造函数都必须遵守 Set 接口施加的其他约束</p></blockquote><p>观察源码可以发现，它只是实现了equals,hashCode,removeAll方法，除此并没有进行其他操作了，这样的简便使得后续Set的实现变得简单和多样。<br>AbstractSet下分三个类，分别是HashSet,TreeSet,EnumSet。我们简单介绍一下： </p><h5 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h5><p>EnumSet是Java集合框架中的一种特殊的集合，它专门用于存储枚举类型的元素。<br>由于枚举类型的取值是有限的、固定的，EnumSet可以使用位向量来表示集合元素，从而提高了性能和空间效率。EnumSet提供了多种操作方法，如add()、remove()、contains()等，同时它还实现了Set接口，因此可以直接使用Set中的大部分方法。</p><p>EnumSet是用来配合枚举类使用的，可以较为方便的管理枚举类<br>提供下面的方法，用来生成EnumSet：</p><ul><li>allOf(类<E> elementType)</li><li>创建一个包含指定元素类型中所有元素的枚举集。</li><li>EnumSet<E>clone()</li><li>返回此集合的副本。</li><li>EnumSet<E>complementOf(EnumSet<E> s)</li><li>创建与指定枚举集具有相同元素类型的枚举集，最初包含此类型的所有元素，该元素 不包含在指定的集合中。</li><li>EnumSet<E>copyOf(Collection<E> c)</li><li>创建从指定集合初始化的枚举集。</li><li>EnumSet<E>copyOf(EnumSet<E> s)</li><li>创建与指定的枚举集相同的元素类型的枚举集，最初包含相同的元素（如果有）。</li><li>EnumSet<E>noneOf(类<E> elementType)</li><li>使用指定的元素类型创建一个空的枚举集。</li><li>EnumSet<E>of(E e)</li><li>创建一个最初包含指定元素的枚举集。</li><li>EnumSet<E>range(E from, E to)</li><li>创建最初包含由两个指定端点定义的范围内的所有元素的枚举集。</li></ul><h5 id="TreeSet-和-HashSet"><a href="#TreeSet-和-HashSet" class="headerlink" title="TreeSet 和 HashSet"></a>TreeSet 和 HashSet</h5><p>由于我们篇幅有限，底层原理先不具体说，所以暂且将两个拿在一起介绍。</p><p>TreeSet是Java集合框架中的一种有序集合，它实现了SortedSet接口，可以根据元素的自然排序或者指定的Comparator进行排序。<br>TreeSet底层是基于红黑树实现的，因此插入、删除、查找等操作的时间复杂度都是O(logN)。TreeSet提供了多种操作方法，如add()、remove()、contains()等，同时它还实现了NavigableSet接口，提供了一些导航方法，如lower()、floor()、ceiling()、higher()等。</p><p>HashSet是Java集合框架中的一种无序集合，它底层是基于HashMap实现的，元素被存储在HashMap的key中，而value是一个常量Object对象，因此具有HashMap的优点，如快速插入、删除、查找等操作。<br>HashSet中的元素是无序的，并且不允许重复元素的存在。HashSet提供了多种操作方法，如add()、remove()、contains()等，同时实现了Set接口，因此可以直接使用Set中的大部分方法。</p><p>它们的使用场景不同：<br>HashSet适用于快速插入、删除、查找元素，并且不需要考虑元素的顺序的场景，如去重、查找等。而TreeSet适用于对元素进行排序和范围查找的场景，如按照年龄、姓名等进行排序和查找。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>MAP部分也是个大内容，时间关系，挖个坑以后填😀</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码中说JUC-2</title>
      <link href="/2023/06/23/%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%AF%B4JUC-2/"/>
      <url>/2023/06/23/%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%AF%B4JUC-2/</url>
      
        <content type="html"><![CDATA[<p>本系列是写在代码里的记录，用来记录juc的学习过程</p><span id="more"></span><p>具体代码在github里嗷~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">本章是对并发的共享模型的学习</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;n3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">n3</span> &#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    首先尝试，两个线程同时对一个静态变量进行操作，会不会出问题</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">problem5000</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 一个线程+，一个线程-，看看数据有没有变化</span><br>        <span class="hljs-comment">// 首先定义好两个线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                res++;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>                res--;<br>            &#125;<br>        &#125;);<br>        add.start();<br>        sub.start();<br>        add.join();<br>        sub.join();<br><br>        log.debug(String.valueOf(res)); <span class="hljs-comment">// 可能==0，可能!=0</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        最后可以看到结果并不是0，由于分时系统，导致可能并没有写进数据，而时间片用完被收回</span><br><span class="hljs-comment">        为什么没有写进去呢？</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        查看字节码(--)可以知道，静态变量的处理是四个操作指令。 ++类似</span><br><span class="hljs-comment">        getstatic #29 &lt;ln/n3/n3.res : I&gt; 把常量池索引为29的静态字段的值放到操作栈上</span><br><span class="hljs-comment">        &gt;&gt; 0</span><br><span class="hljs-comment">        iconst_1 把1推到操作栈上</span><br><span class="hljs-comment">        &gt;&gt; 0-&gt;1</span><br><span class="hljs-comment">        isub 执行减操作</span><br><span class="hljs-comment">        &gt;&gt; -1</span><br><span class="hljs-comment">        putstatic #29 &lt;ln/n3/n3.res : I&gt; 把操作栈的数放到索引为29的静态字段上</span><br><span class="hljs-comment">        &gt;&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        上面是正常情况下，单线程的读写操作，那多线程呢？</span><br><span class="hljs-comment">        getstatic</span><br><span class="hljs-comment">        &gt;&gt; 0</span><br><span class="hljs-comment">        iconst_1</span><br><span class="hljs-comment">        &gt;&gt; 0-&gt;1</span><br><span class="hljs-comment">        isub</span><br><span class="hljs-comment">        &gt;&gt; -1</span><br><span class="hljs-comment">                       |getstatic</span><br><span class="hljs-comment">                       &gt;&gt; 0</span><br><span class="hljs-comment">                       iconst_1</span><br><span class="hljs-comment">                       &gt;&gt; 0-&gt;1</span><br><span class="hljs-comment">                       iadd</span><br><span class="hljs-comment">                       &gt;&gt; 1</span><br><span class="hljs-comment">                       putstatic</span><br><span class="hljs-comment">                       &gt;&gt;   写入静态变量1</span><br><span class="hljs-comment">         putstatic</span><br><span class="hljs-comment">         &gt;&gt;    写入静态变量-1</span><br><span class="hljs-comment">         这时原本好端端的0，就被迟来的指令改变了，成为了-1</span><br><span class="hljs-comment">         */</span><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    可以使用互斥锁，将对象锁住进行操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSys</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123; <span class="hljs-comment">//保证i++线程走完</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">500</span>; i1++) &#123;<br>                    i++;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123; <span class="hljs-comment">// 保证循环内所有代码走完</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">500</span>; i1++) &#123;<br>                    i--;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        thread1.start();<br>        thread2.start();<br><br>        thread1.join();<br>        thread2.join();<br><br>        log.debug(<span class="hljs-string">&quot;结果为：&#123;&#125;&quot;</span>, i);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        类似分析</span><br><span class="hljs-comment">        线程1             |线程2              |锁对象</span><br><span class="hljs-comment">        -------------------------------------&gt;获取锁</span><br><span class="hljs-comment">        getstati</span><br><span class="hljs-comment">        &gt;&gt; 0</span><br><span class="hljs-comment">        iconst_1</span><br><span class="hljs-comment">        &gt;&gt; 0-&gt;1</span><br><span class="hljs-comment">        isub</span><br><span class="hljs-comment">        &gt;&gt; -1</span><br><span class="hljs-comment">        时间片切换          |</span><br><span class="hljs-comment">                          --------------------&gt;获取锁，获取失败，进入block阻塞状态，切换时间片</span><br><span class="hljs-comment">        putstatic</span><br><span class="hljs-comment">         &gt;&gt;写入静态变量-1</span><br><span class="hljs-comment">        -------------------------------------&gt;释放锁，并唤醒所有阻塞状态线程</span><br><span class="hljs-comment">                           --------------------&gt;获取锁</span><br><span class="hljs-comment">                           getstati</span><br><span class="hljs-comment">                           &gt;&gt; -1</span><br><span class="hljs-comment">                           iconst_1</span><br><span class="hljs-comment">                           &gt;&gt; -1-&gt;1</span><br><span class="hljs-comment">                           isub</span><br><span class="hljs-comment">                           &gt;&gt; 0</span><br><span class="hljs-comment">                           putstatic</span><br><span class="hljs-comment">                           &gt;&gt;写入静态变量0</span><br><span class="hljs-comment">                           --------------------&gt;释放锁，并唤醒所有阻塞状态线程</span><br><span class="hljs-comment">         */</span><br><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    改进上面的方式，使用对象的方式进行保护</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getVal</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br><br>        <span class="hljs-comment">// 可以加在方法上面，相当于锁住了方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVal</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addVal</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-built_in">this</span>.val++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subVal</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-built_in">this</span>.val--;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSysObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 只需要调用方法即可，对象自身方法实现了对象锁</span><br>        <span class="hljs-type">Room</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Room</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">500</span>; i1++) &#123;<br>                room.addVal();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">500</span>; i1++) &#123;<br>                room.subVal();<br>            &#125;<br>        &#125;);<br>        thread.start();<br>        thread1.start();<br><br>        thread.join();<br>        thread1.join();<br><br>        log.debug(<span class="hljs-string">&quot;结果为：&#123;&#125;&quot;</span>, room.getVal());<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    分析线程不安全的情况：</span><br><span class="hljs-comment">    1.  成员变量和静态变量分析，静态变量在方法区中，成员变量在堆（对象里）中</span><br><span class="hljs-comment">    它们如果是非共享的，没有安全问题</span><br><span class="hljs-comment">    如果是共享的，如果有临界区，则有安全问题</span><br><span class="hljs-comment">    2.  局部变量是否线程安全，局部变量在方法里，是线程安全的，但是局部变量引用的对象，安全问题</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadUnsafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         让多线程共享变量操作出现问题，因为list为共享变量，同时add实际会调用容量++，但容量++前面分析了，</span><br><span class="hljs-comment">         在写入的时候，时间片用完，无法写入，后续再进行写入，数据不齐，导致临界区发送竞态条件</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 定义一个内部类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">tUnsafe</span> &#123;<br>            ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-built_in">this</span>.list.add(<span class="hljs-number">1</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-built_in">this</span>.list.remove(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">tUnsafe</span> <span class="hljs-variable">tu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">tUnsafe</span>();<br>        <span class="hljs-comment">// 不断操作tUnsafe对象</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">1000</span>; i1++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (; <span class="hljs-literal">true</span>; ) &#123;<br>                    <span class="hljs-comment">// 临界区</span><br>                    <span class="hljs-comment">// 发生了竞态条件</span><br>                    tu.add();<br>                    tu.remove();<br>                &#125;<br>            &#125;, String.valueOf(i1)).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadSafe</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         在这里，list为局部变量，仅在一个方法中，不同方法的list不同，不干扰</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-comment">// 定义一个内部类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">tSafe</span> &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>                ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                add(list);<br>                remove(list);<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>                list.add(<span class="hljs-number">1</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>                list.remove(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">tSafe</span> <span class="hljs-variable">ts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">tSafe</span>();<br><br>        <span class="hljs-comment">// 由于线程正常，则定个计时器</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            &#125;<br>        &#125;);<br>        thread.start();<br>        <span class="hljs-comment">// 不断操作tSafe对象</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">1000</span>; i1++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (; <span class="hljs-literal">true</span>; ) &#123;<br>                    ts.m1();<br>                &#125;<br>            &#125;, String.valueOf(i1)).start();<br>        &#125;<br>        thread.join(<span class="hljs-number">100</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 局部变量如果被暴露在外面，则还是会出现临界区</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadExpose</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">t</span> &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 可以看到，即使只操作一遍，但是由于多个线程共同操作共享变量，也会出现竞态条件</span><br>                ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                System.out.println(System.identityHashCode(list));<br>                add(list);<br>                remove(list);<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>                list.add(<span class="hljs-number">1</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>                list.remove(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 这里继承重写方法，相当于多开了线程</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">t1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">t</span> &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                    list.add(<span class="hljs-number">1</span>);<br>                &#125;).start();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(ArrayList&lt;Integer&gt; list)</span> &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                    list.remove(<span class="hljs-number">0</span>);<br>                &#125;).start();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">t1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">t1</span>();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (; <span class="hljs-literal">true</span>; ) &#123;<br>                t1.m1();<br>            &#125;<br>        &#125;);<br><br>        thread.start();<br>        thread.join();<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    String 和 Integer为不可变类，保证线程安全，因为它不可变</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345&quot;</span>;<br>        System.out.println(System.identityHashCode(a));<br>        a = <span class="hljs-string">&quot;2&quot;</span>;<br>        System.out.println(System.identityHashCode(a));<br>        System.out.println(System.identityHashCode(<span class="hljs-string">&quot;2&quot;</span>));<br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">129</span>;<br>        System.out.println(System.identityHashCode(b));<br>        b = <span class="hljs-number">130</span>;<br>        System.out.println(System.identityHashCode(b));<br>        System.out.println(System.identityHashCode(<span class="hljs-number">130</span>));<br><br>        <span class="hljs-comment">// 顺便说明在java中Integer，若取值在-127~127之间，则对象相同，</span><br>        <span class="hljs-comment">// 因为：</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">300</span>; i1++) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> i1;<br>            <span class="hljs-keyword">if</span> (System.identityHashCode(c) != System.identityHashCode(i1)) &#123;<br>                System.out.println(i1);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    探索轻量级锁</span><br><span class="hljs-comment">    先加轻量级锁，在java虚拟机栈里存有栈帧lockRecord</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lightLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-comment">// 首先Object对象头MonitorWord和主线程的lockRecord的MonitorWord相似的部分交换,</span><br>        <span class="hljs-comment">// 使得还没上锁的o，状态从01变成了monitorWord的00，同时记录相应的lockRecord信息</span><br>        <span class="hljs-keyword">synchronized</span> (o) &#123;<br>            <span class="hljs-comment">// 查看如果是在本线程，就是只增加一个栈帧lockRecord，然后记录信息为null</span><br>            <span class="hljs-keyword">synchronized</span> (o) &#123;<br>                log.debug(<span class="hljs-string">&quot;hi&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 这是简单且理想状态下：</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         1.有线程已经拥有对象，则进入锁膨胀阶段</span><br><span class="hljs-comment">         锁膨胀流程：</span><br><span class="hljs-comment">         首先把原先的00，换成10，前面那两位（XX 10 MonitorWord4个字节）指向一个monitor对象</span><br><span class="hljs-comment">         type monitor &#123;</span><br><span class="hljs-comment">            Thread owner;</span><br><span class="hljs-comment">            Thread[] waitSet;</span><br><span class="hljs-comment">            Thread[] entitySet;</span><br><span class="hljs-comment">         &#125;</span><br><span class="hljs-comment">         entitySet把要申请锁的线程添加，并变成阻塞状态。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         在解锁的时候，原先线程先尝试轻量级解锁方式，就是简单的交换monitorWord，如果行不通，则变成重量级锁解锁方式</span><br><span class="hljs-comment">         2.自己线程已经拥有对象，则空加lockRecord</span><br><span class="hljs-comment">         */</span><br>    &#125;<br><br>    <span class="hljs-comment">// 探索偏向锁 Biased</span><br>    <span class="hljs-comment">// 在这里用了新的jar包，jol</span><br>    <span class="hljs-comment">// 记得vm参数有开启偏向锁</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">biasedLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 在这里先随便创建一个对象</span><br>        ArrayList&lt;Integer&gt; o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 先打印一下，看到</span><br>        <span class="hljs-comment">// 0 8 (object header: mark) 0x0000000000000005 (biasable; age: 0)</span><br>        <span class="hljs-comment">// 说明上锁</span><br>        log.debug(ClassLayout.parseInstance(o).toPrintable());<br><br>        <span class="hljs-comment">// 使用锁</span><br>        <span class="hljs-keyword">synchronized</span> (o) &#123;<br>            <span class="hljs-comment">// 打印</span><br>            <span class="hljs-comment">// 说明上锁，并标记线程为···</span><br>            <span class="hljs-comment">// 例如：0   8 (object header: mark) 0x000002d4e42bc005 (biased: 0x00000000b5390af0; epoch: 0; age: 0)</span><br>            log.debug(ClassLayout.parseInstance(o).toPrintable());<br>        &#125;<br><br>        <span class="hljs-comment">// 线程直接使用锁</span><br>        log.debug(ClassLayout.parseInstance(o).toPrintable());<br><br>        <span class="hljs-comment">// 换个线程使用</span><br>        <span class="hljs-comment">// 切换轻量级锁</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (o) &#123;<br>                log.debug(ClassLayout.parseInstance(o).toPrintable());<br>            &#125;<br>        &#125;);<br><br>        thread.start();<br><br>        <span class="hljs-comment">// 最后检查，发现最后回到01，无锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            thread.join();<br>            log.debug(ClassLayout.parseInstance(o).toPrintable());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 小贴士：用hashCode会禁用偏向锁</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hashCodeMagic</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        o.hashCode();<br><br>        <span class="hljs-comment">// 例如：</span><br>        <span class="hljs-comment">// 0   8        (object header: mark)     0x000000146ba0ac01 (hash: 0x146ba0ac; age: 0)</span><br>        log.debug(ClassLayout.parseInstance(o).toPrintable());<br>        <span class="hljs-comment">// 因为0 01状态（无锁）下，存储31位hashcode，</span><br>        <span class="hljs-comment">// 但是在1 01状态（偏向锁）下，不能存储hashcode，所以在调用hashCode后，不会给hashCode</span><br><br>        <span class="hljs-comment">// 那为什么不是偏向锁，轻量级锁和重量级锁没有hashcode，却能查询呢？</span><br>        <span class="hljs-comment">// 因为追起溯源，其实是markWord是交换过来的信息，也就是说线程存储之前交换的信息，可以用它找到hashCode</span><br>        <span class="hljs-comment">// 准确来说，轻量级锁存在线程栈帧里</span><br>        <span class="hljs-comment">// 重量级锁存在monitor对象里</span><br>        <span class="hljs-comment">// 而用偏向锁的话，直接是覆盖掉了，不是交换过去还存在</span><br>        <span class="hljs-keyword">synchronized</span> (o) &#123;<br>            o.hashCode();<br>            log.debug(ClassLayout.parseInstance(o).toPrintable());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    偏向锁撤销：</span><br><span class="hljs-comment">    1.使用hashCode</span><br><span class="hljs-comment">    2.使用wait notify (只有重量级锁才有)</span><br><span class="hljs-comment">    3.使用过一次其他的锁</span><br><span class="hljs-comment">    4.批量撤销了，在之后类新建的对象也不会上偏向锁了</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBatch</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>        &#125;<br><br>        LinkedList&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 首先测试批量重偏向</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i1 &lt; <span class="hljs-number">50</span>; i1++) &#123;<br>                <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>                <span class="hljs-keyword">synchronized</span> (dog) &#123;<br>                    dogs.add(dog);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">synchronized</span> (dogs) &#123;<br>                dogs.notify();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t0&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 等待和打印</span><br>            <span class="hljs-keyword">synchronized</span> (dogs) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    dogs.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>            log.debug(ClassLayout.parseInstance(dogs.get(<span class="hljs-number">0</span>)).toPrintable()); <span class="hljs-comment">// 看第一个和最后一个是否上偏向锁d</span><br>            log.debug(ClassLayout.parseInstance(dogs.get(dogs.size() - <span class="hljs-number">1</span>)).toPrintable());<br><br>            <span class="hljs-keyword">for</span> (Dog dog : dogs) &#123;<br>                <span class="hljs-keyword">synchronized</span> (dog) &#123;<br>                &#125;<br>            &#125;<br><br>            log.debug(ClassLayout.parseInstance(dogs.get(<span class="hljs-number">0</span>)).toPrintable()); <span class="hljs-comment">// 看第一个和最后一个是否上偏向锁d</span><br>            log.debug(ClassLayout.parseInstance(dogs.get(dogs.size() - <span class="hljs-number">1</span>)).toPrintable());<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        thread1.start();<br>        thread2.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            thread1.join();<br>            thread2.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br>        <span class="hljs-comment">// 因为之前是达到20次，就重偏向2了，所以需要再来20次</span><br>        <span class="hljs-keyword">for</span> (Dog dog : dogs) &#123;<br>            <span class="hljs-keyword">synchronized</span> (dog) &#123;<br>            &#125;<br>        &#125;<br>        log.debug(ClassLayout.parseInstance(dogs.get(<span class="hljs-number">0</span>)).toPrintable()); <span class="hljs-comment">// 看第一个和最后一个是否上偏向锁d</span><br>        log.debug(ClassLayout.parseInstance(dogs.get(dogs.size() - <span class="hljs-number">1</span>)).toPrintable());<br><br>        <span class="hljs-comment">// 达到40次后，再无重偏向了</span><br>        log.debug(ClassLayout.parseInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()).toPrintable());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码中说JUC-1</title>
      <link href="/2023/06/23/%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%AF%B4JUC-1/"/>
      <url>/2023/06/23/%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%AF%B4JUC-1/</url>
      
        <content type="html"><![CDATA[<p>本系列是写在代码里的记录，用来记录juc的学习过程</p><span id="more"></span><p>具体代码在github里嗷~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  线程常用方法</span><br><span class="hljs-comment">  @author trotro</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;n2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">n2</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      创建线程</span><br><span class="hljs-comment">      列举主要三种模式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">creatThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 第一种创建线程方法</span><br>        <span class="hljs-comment">// 直接使用Thread类，写一个匿名内部类，同时重写run方法</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;innerClass&quot;</span>) &#123;<br>            <span class="hljs-comment">//重写run</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>            &#125;<br>        &#125;;<br>        thread.start();<br><br>        <span class="hljs-comment">// 第二种使用Runnable配合Thread</span><br>        <span class="hljs-comment">// 实现Runnable方法</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">running2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;running2&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(running2, <span class="hljs-string">&quot;Runnable&quot;</span>);<br>        thread1.start();<br><br>        <span class="hljs-comment">// 第二点五种使用Lambda配合Thread</span><br>        <span class="hljs-comment">// 比较常用嗷</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; log.debug(<span class="hljs-string">&quot;running3&quot;</span>), <span class="hljs-string">&quot;lambda&quot;</span>);<br>        thread2.start();<br><br>        <span class="hljs-comment">// 第三种使用FutureTask配合Thread</span><br>        <span class="hljs-comment">// FutureTask能够接受返回值</span><br><br>        FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;task&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task, <span class="hljs-string">&quot;Future&quot;</span>);<br>        thread3.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;出现结果:&#123;&#125;&quot;</span>, task.get());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br><br>        log.debug(<span class="hljs-string">&quot;main&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      观察线程</span><br><span class="hljs-comment">      看到线程交替运行</span><br><span class="hljs-comment">      1.使用window(tasklist)或linux(ps)(top -H -p pid查看这个pid的所有进程实时)提供的查看方式</span><br><span class="hljs-comment">      2.jps 查看所有java的进程，和pid</span><br><span class="hljs-comment">      3.jstack pid 查看该pid的所有进程</span><br><span class="hljs-comment">      4.jconsole pid 图形化查看pid</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                log.debug(<span class="hljs-string">&quot;running&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                log.debug(<span class="hljs-string">&quot;2Running&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     使用Debug 观察栈帧，可以看到线程是在操作中可以随时创建的</span><br><span class="hljs-comment">     上下文切换：</span><br><span class="hljs-comment">     触发线程的被动方法，例如时间片用完（任务调度器在时钟提醒后，会进行任务调度切换线程）、</span><br><span class="hljs-comment">     垃圾回收（在垃圾回收的时候，会切换线程到垃圾回收的线程）、有更高的优先级线程调用</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     触发上下文切换的主动方法，</span><br><span class="hljs-comment">     线程内部使用&#123;Thread.sleep()&#125;将对cpu的使用放弃xx秒</span><br><span class="hljs-comment">     &#123;Thread.yield&#125;主动放弃对cpu的使用，优先让其他线程使用</span><br><span class="hljs-comment">     &#123;thread.wait()&#125;（不建议直接使用wait）让当前线程等待直到它被唤醒，通常是通过通知或中断</span><br><span class="hljs-comment">     &#123;thread.join()&#125;同上</span><br><span class="hljs-comment">     &#123;park synchronized lock&#125;同样也会触发上下文切换</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">frames</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                log.debug(<span class="hljs-string">&quot;hihi&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br>        thread.start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                log.debug(<span class="hljs-string">&quot;hihi&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;).start();<br><br>        log.debug(String.valueOf(System.nanoTime()));<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      常用方法：</span><br><span class="hljs-comment">      start与run</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methods</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 运行可以看到线程名字为main，所以run只是单纯调用关系</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(Thread.currentThread().getName());<br>        &#125;);<br>        thread.start();<br>        thread.run();<br>        log.debug(<span class="hljs-string">&quot;start&quot;</span>);<br><br>        log.debug(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);<br>        <span class="hljs-comment">// 打断</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (Thread.class) &#123;<br>                log.debug(<span class="hljs-string">&quot;sleep&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                    TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    log.debug(<span class="hljs-string">&quot;wake up!&quot;</span>);<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        thread1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            thread1.interrupt();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      优先级和yield</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">yieldP</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// 定义方法变量</span><br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">res0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">res1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                res0.getAndIncrement(); <span class="hljs-comment">// +1</span><br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//                    Thread.yield();</span><br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                res1.getAndIncrement(); <span class="hljs-comment">// +1</span><br>            &#125;<br>        &#125;);<br><br><span class="hljs-comment">//        thread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="hljs-comment">//        thread1.setPriority(Thread.MIN_PRIORITY);</span><br><br><br>        <span class="hljs-comment">// 启动线程</span><br>        thread.start();<br>        thread1.start();<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        thread.interrupt();<br>        thread1.interrupt();<br><br>        <span class="hljs-comment">// 查看结果</span><br>        log.debug(<span class="hljs-string">&quot;thread0:&#123;&#125;&quot;</span>, res0.get());<br>        log.debug(<span class="hljs-string">&quot;thread1:&#123;&#125;&quot;</span>, res1.get());<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        可以看到，yield()对线程的影响还是十分大的。</span><br><span class="hljs-comment">        向调度程序提示当前线程愿意放弃其当前对处理器的使用。调度程序可以随意忽略此提示。</span><br><span class="hljs-comment">        Yield 是一种启发式尝试，旨在改善线程之间的相对进度，否则会过度使用 CPU。它的使用应与详细的分析和基准测试相结合，以确保它确实具有预期的效果。</span><br><span class="hljs-comment">        使用这种方法很少是合适的。它可能对调试或测试有用，因为它可能有助于重现由于竞争条件导致的错误。在设计并发控制结构（如java.util.concurrent.locks包中的结构）时，它也可能很有用。</span><br><span class="hljs-comment">         */</span><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     join的使用场景</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testJoin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                log.debug(<span class="hljs-string">&quot;yeyeyeyey&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br>        thread.start();<br>        log.debug(<span class="hljs-string">&quot;不使用join&quot;</span>);<br>        log.debug(<span class="hljs-string">&quot;线程状态：&#123;&#125;&quot;</span>, thread.getState());<br><br>        log.debug(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            thread.join();<br>            log.debug(<span class="hljs-string">&quot;线程状态：&#123;&#125;&quot;</span>, thread.getState());<br>            log.debug(<span class="hljs-string">&quot;使用join&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    打断标记</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptFlag</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 1.在正常情况下（非sleep，wait，join阻塞状态时候）进行打断，会标记上打断标记</span><br>        <span class="hljs-comment">// 注意，这种情况下不会停止线程运行</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-comment">//                可以用来手动停止线程运行</span><br><span class="hljs-comment">//                if (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="hljs-comment">//                    break;</span><br><span class="hljs-comment">//                &#125;</span><br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 开始</span><br>        log.debug(<span class="hljs-string">&quot;start&quot;</span>);<br>        thread.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br>        <span class="hljs-comment">//两秒后打断</span><br>        log.debug(<span class="hljs-string">&quot;interrupt&quot;</span>);<br>        thread.interrupt();<br><br>        <span class="hljs-comment">//查看状态</span><br>        log.debug(<span class="hljs-string">&quot;打断标记：&#123;&#125;&quot;</span>, thread.isInterrupted());<br>        log.debug(<span class="hljs-string">&quot;线程状态:&#123;&#125;&quot;</span>, thread.getState()); <span class="hljs-comment">//仍然运行</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br><br><br>        log.debug(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;.&quot;</span>);<br><br><br><br>        <span class="hljs-comment">// 2.在sleep,或者wait、join的时候打断，会是false，因为trycatch直接捕获了异常</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">interruptSleep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                log.warn(e.toString());<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 开始</span><br>        interruptSleep.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br><br>        <span class="hljs-comment">//一秒后打断</span><br>        interruptSleep.interrupt();<br>        log.debug(<span class="hljs-string">&quot;打断标记为:&#123;&#125;&quot;</span>, interruptSleep.isInterrupted());<br>        log.debug(<span class="hljs-string">&quot;线程状态:&#123;&#125;&quot;</span>, interruptSleep.getState()); <span class="hljs-comment">//TERMINATED 终止</span><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    打断标记interrupted和park</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptAndPark</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// park是locks的方法，用来让线程处阻塞状态</span><br>            log.debug(<span class="hljs-string">&quot;park&quot;</span>);<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark，打断标记为：&#123;&#125;&quot;</span>, Thread.currentThread().isInterrupted());<br><br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;由于打断标记为true，park无用&quot;</span>);<br>        &#125;);<br><br>        thread.start();<br><br>        <span class="hljs-comment">// 1秒后打断</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        thread.interrupt();<br><br>        thread.join();<br><br><span class="hljs-comment">//        &gt;&gt;&gt;&gt;&gt;&gt;</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;park&quot;</span>);<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark, 打断标记为:&#123;&#125;，顺便清楚打断标记&quot;</span>, Thread.interrupted());<br><br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;unpark，看不见嗷&quot;</span>);<br>        &#125;);<br><br>        thread1.start();<br><br>        <span class="hljs-comment">// 1秒后打断</span><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        thread1.interrupt();<br><br>        thread1.join();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testThread</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;结束了&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        thread.start();<br><br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br><br>        log.debug(<span class="hljs-string">&quot;我go啦&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细聊Java的Stream流(看源码)</title>
      <link href="/2023/06/02/%E4%BB%94%E7%BB%86%E7%A0%94%E7%A9%B6Java%E7%9A%84Stream%E6%B5%81/"/>
      <url>/2023/06/02/%E4%BB%94%E7%BB%86%E7%A0%94%E7%A9%B6Java%E7%9A%84Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>Stream流是jdk8以后的特性，通过stream流，实现对Collection集合的便利操作。<br>本文研究创建Stream和使用Stream，但注意并不是全面的，只是大致流程。</p><span id="more"></span><p>整体分为创建Stream和使用Stream（重点）</p><h1 id="创建Stream"><a href="#创建Stream" class="headerlink" title="创建Stream"></a>创建Stream</h1><p><img src="/../../image/img.png" alt="img.png"><br>通过idea分析图，可知Stream有多个接口，含有Stream、IntStream、LongStream、DoubleStream，XXStream是Stream的XX原始特化，<br>它们提供描述方法和限制，和默认实现。可以使用stream()，生成流（实际是XPipeline管道），实际流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 使用Stream.of(..)直接创建时候，调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(T... values)</span> &#123;<br>        <span class="hljs-keyword">return</span> Arrays.stream(values);<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Streams</span>.StreamBuilderImpl&lt;&gt;(t), <span class="hljs-literal">false</span>);<br>    &#125;<br><br><span class="hljs-comment">//比如使用Collection.stream()时候，调用</span><br><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">false</span>);<br>    &#125;<br><br><span class="hljs-comment">// 使用Arrays.stream(array)时候，调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">(T[] array)</span> &#123;<br>        <span class="hljs-keyword">return</span> stream(array, <span class="hljs-number">0</span>, array.length);<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">(T[] array, <span class="hljs-type">int</span> startInclusive, <span class="hljs-type">int</span> endExclusive)</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(array, startInclusive, endExclusive), <span class="hljs-literal">false</span>);<br>    &#125;<br><span class="hljs-comment">// 注意使用double, Int。只是把数组拆分开，然后仍然调用Arrays.stream(array)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IntStream <span class="hljs-title function_">of</span><span class="hljs-params">(<span class="hljs-type">int</span>... values)</span> &#123;<br>        <span class="hljs-keyword">return</span> Arrays.stream(values);<br>    &#125;<br>    <br><span class="hljs-comment">// 其他类似</span><br></code></pre></td></tr></table></figure><p>可以看到都是最终调用StreamSupport的静态方法stream， stream的两个参数spliterator和parallel是什么呢？</p><blockquote><p>StreamSupport 提供创建和操作流的低级实用方法。</p></blockquote><p>Spliterator 是用来遍历和划分源元素的对象，可以单独遍历元素和按顺序批量遍历，类似Iterator，再往下就不研究了，属于别的内容了，总之Stream就是用它来进行一系列操作。</p><p>parallel 是用来选择是顺序流(false)还是并行流(true)。</p><p>当然，StreamSupport也提供了其他的创建流方式，这里说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">(Supplier&lt;? extends Spliterator&lt;T&gt;&gt; supplier,</span><br><span class="hljs-params">                                       <span class="hljs-type">int</span> characteristics,</span><br><span class="hljs-params">                                       <span class="hljs-type">boolean</span> parallel)</span> &#123;<br>        Objects.requireNonNull(supplier);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferencePipeline</span>.Head&lt;&gt;(supplier,<br>                                            StreamOpFlag.fromCharacteristics(characteristics),<br>                                            parallel);<br>    &#125;<br></code></pre></td></tr></table></figure><p>supplier是函数接口，用来提供Spliterator。<br>characteristics是与流和操作的特征相对应的标志。流框架使用标志来控制、专门化或优化计算，可用于描述与流关联的几个不同实体的特征：流源、中间操作和终端操作。<br>parallel 和上述的一样作用</p><p>继续深入，可以发现不同的Stream对应不同的Pipeline，Pipeline调用父类构造函数，构造Pipeline</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java">AbstractPipeline(Supplier&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Spliterator</span>&lt;?&gt;&gt; source,<br>                     <span class="hljs-type">int</span> sourceFlags, <span class="hljs-type">boolean</span> parallel) &#123;<br>        <span class="hljs-built_in">this</span>.previousStage = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.sourceSupplier = source;<br>        <span class="hljs-built_in">this</span>.sourceStage = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-built_in">this</span>.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;<br>        <span class="hljs-comment">// The following is an optimization of:</span><br>        <span class="hljs-comment">// StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);</span><br>        <span class="hljs-built_in">this</span>.combinedFlags = (~(sourceOrOpFlags &lt;&lt; <span class="hljs-number">1</span>)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;<br>        <span class="hljs-built_in">this</span>.depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.parallel = parallel;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在这里设置了头部节点，源Spliterator，源节点，流合并，流合并用的，头深度，并行流。<br>可以发现AbstractPipeline才是我们流的关键，所有Pipeline调用AbstractPipeline构造，同时所有Stream使用StreamSupport来调用Pipeline创建管道。<br>这里官方文档(机翻)：</p><blockquote><p>“管道”类的抽象基类，它们是 Stream 接口及其原始特化的核心实现。管理流管道的建设和评估。<br>AbstractPipeline表示流管道的初始部分，封装流源和零个或多个中间操作。各个AbstractPipeline对象通常称为阶段，其中每个阶段描述流源或中间操作。<br>具体的中间阶段通常是从AbstractPipeline构建的，一个扩展它的形状特定的管道类（例如， IntPipeline ）也是抽象的，以及一个扩展它的特定于操作的具体类。 AbstractPipeline包含评估管道的大部分机制，并实现操作将使用的方法；特定于形状的类添加了辅助方法，用于将结果集合处理到适当的特定于形状的容器中。<br>在链接新的中间操作或执行终端操作后，流被认为已被消耗，并且不允许对该流实例进行更多的中间或终端操作。<br>实际说明：<br>对于顺序流和没有有状态中间操作的并行流，并行流，管道评估是在一次通过中完成的，它将所有操作“堵塞”在一起。对于有状态操作的并行流，执行被分成多个段，其中每个有状态操作标记一个段的结束，每个段被单独评估，并将结果用作下一个段的输入。在所有情况下，直到终端操作开始时才使用源数据。</p></blockquote><p>总结一下,stream每次创建实际对象为X_Pipeline.<Head>类型，我们可以通过研究X_Pipeline.<Head>获取我们想要知道的实际方法，<br>当然在使用过程时，由于方法返回的是不同的实现Stream方法的类和其他返回类型，所以我们要具体分析。</p><blockquote><p>注意，Stream.of和Arrays.stream均使用Arrays.stream，它有多个不同参数，如果明确为基本类型的，就会返回IntStream、LongStream、DoubleStream，<br>如果为其他，则为Stream<T>。虽然实际类型为X_Pipeline.<Head>管道类型，但是类引用的类型是不同的，所能使用的方法是不同的。</p></blockquote><h2 id="分析涉及管道的结构"><a href="#分析涉及管道的结构" class="headerlink" title="分析涉及管道的结构"></a>分析涉及管道的结构</h2><p>刚才我们顺着整体的创建过程分析，可以发现用方法是流，实际载体是管道，StreamSupport连接这二者。<br>其中StreamSupport返回的new __Pipeline.Head类型，正是，我们管道结构的头。<br>分析管道数据属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 链表的头节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractPipeline sourceStage;<br><span class="hljs-comment">// 前一个节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractPipeline previousStage;<br><span class="hljs-comment">// 用于合并</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> sourceOrOpFlags;<br><span class="hljs-comment">// 下一个节点</span><br><span class="hljs-keyword">private</span> AbstractPipeline nextStage;<br><span class="hljs-comment">// 节点深度</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> depth;<br><span class="hljs-comment">// 用于合并</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> combinedFlags;<br><br><span class="hljs-comment">// 源Spliterator，用于处理数据</span><br><span class="hljs-keyword">private</span> Spliterator&lt;?&gt; sourceSpliterator;<br><span class="hljs-comment">// 和Spliterator类似</span><br><span class="hljs-keyword">private</span> Supplier&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Spliterator</span>&lt;?&gt;&gt; sourceSupplier;<br><br><span class="hljs-comment">// 判断是否管道被连接或者消费</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> linkedOrConsumed;<br><span class="hljs-comment">// 是否是有状态的操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> sourceAnyStateful;<br><span class="hljs-comment">// 可以用于多线程关闭的</span><br><span class="hljs-keyword">private</span> Runnable sourceCloseAction;<br><span class="hljs-comment">// 并行流</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> parallel;<br></code></pre></td></tr></table></figure><p>再分析重要内部类:<br>无状态阶段:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StatelessOp</span>&lt;E_IN, E_OUT&gt;<br>            <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReferencePipeline</span>&lt;E_IN, E_OUT&gt; &#123;<br>        StatelessOp(AbstractPipeline&lt;?, E_IN, ?&gt; upstream,<br>                    StreamShape inputShape,<br>                    <span class="hljs-type">int</span> opFlags) &#123;<br>            <span class="hljs-built_in">super</span>(upstream, opFlags);<br>            <span class="hljs-keyword">assert</span> upstream.getOutputShape() == inputShape;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">opIsStateful</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>有状态阶段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StatefulOp</span>&lt;E_IN, E_OUT&gt;<br>            <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReferencePipeline</span>&lt;E_IN, E_OUT&gt; &#123;<br>        StatefulOp(AbstractPipeline&lt;?, E_IN, ?&gt; upstream,<br>                   StreamShape inputShape,<br>                   <span class="hljs-type">int</span> opFlags) &#123;<br>            <span class="hljs-built_in">super</span>(upstream, opFlags);<br>            <span class="hljs-keyword">assert</span> upstream.getOutputShape() == inputShape;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">opIsStateful</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">abstract</span> &lt;P_IN&gt; Node&lt;E_OUT&gt; <span class="hljs-title function_">opEvaluateParallel</span><span class="hljs-params">(PipelineHelper&lt;E_OUT&gt; helper,</span><br><span class="hljs-params">                                                       Spliterator&lt;P_IN&gt; spliterator,</span><br><span class="hljs-params">                                                       IntFunction&lt;E_OUT[]&gt; generator)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到它们继承ReferencePipeline(当然其他Pipeline里，继承其他Pipeline)，可以看作一片一片的管道，它们存储操作，最终再进行操作，<br>它们通过调用父节点，实现链表的连接，形成下面的结构：<br>Head &lt;&#x3D;&#x3D;&gt; StatelessOp &lt;&#x3D;&#x3D;&gt; StatelessOp</p><blockquote><p>重点是通过重写StatelessOp的opWrapSink方法，然后在最后操作时候被调用，因为其实现了Consumer的接口，可以被源Spliterator调用</p></blockquote><p>Sink是操作元对象，官方文档如下（机翻）:</p><blockquote><p>Consumer的扩展，用于通过流管道的各个阶段传递值，并使用其他方法来管理大小信息、控制流等。在第一次调用Sink上的accept()方法之前，必须先调用begin()方法来通知它数据即将到来（可选地通知接收器有多少数据即将到来），并且在发送完所有数据之后，您必须调用end()方法。在调用end()之后，你不应该在没有再次调用begin()下调用accept() 。 Sink还提供了一种机制，通过该机制，sink 可以协同发出信号表示它不想再接收任何数据（ cancellationRequested()方法），源可以在向Sink发送更多数据之前对其进行轮询。<br>接收器可能处于两种状态之一：初始状态和活动状态。它以初始状态开始； begin()方法将其转换为活动状态， end()方法将其转换回初始状态，以便重新使用。数据接受方法（如accept()仅在活动状态下有效。<br>API说明：<br>流管道由源、零个或多个中间阶段（例如过滤或映射）和终端阶段（例如归约或 for-each）组成。具体来说，考虑管道：<br>int longestStringLengthStartingWith &#x3D; strings.stream().filter(s -&gt; s.startsWith(“A”)).mapToInt(String::length).max();<br>在这里，我们有三个阶段，过滤、映射和减少。过滤阶段使用字符串并发出这些字符串的一个子集；映射阶段使用字符串并发出整数；缩减阶段使用这些整数并计算最大值。<br>Sink实例用于表示此管道的每个阶段，无论该阶段接受对象、整数、长整数还是双精度数。 Sink 具有accept(Object) 、 accept( int )等的入口点，因此我们不需要为每个原始特化提供专门的接口。 （对于这种杂食性趋势，它可能被称为“厨房水槽”。）管道的入口点是过滤阶段的Sink ，它向“下游”发送一些元素——进入映射阶段的Sink ，而水槽又将整数值向下游发送到Sink以进行缩减阶段。与给定阶段关联的Sink实现应该知道下一阶段的数据类型，并在其下游Sink上调用正确的accept方法。同样，每个阶段都必须实现与其接受的数据类型相对应的正确accept方法。<br>Sink.OfInt等专用子类型覆盖accept(Object)以调用accept的适当原语特化，实现Consumer的适当原语特化，并重新抽象accept的适当原语特化。<br>Sink.ChainedInt等链接子类型不仅实现了Sink.OfInt ，还维护了一个代表下游Sink downstream字段，并实现了begin() 、 end()和cancellationRequested()方法委托给下游Sink 。大多数中间操作的实现将使用这些链接包装器。例如，上面示例中的映射阶段如下所示：<br>IntSink is &#x3D; new Sink.ChainedReference<U>(sink) {public void accept(U u) {downstream.accept(mapper.applyAsInt(u));}};<br>在这里，我们实现了Sink.ChainedReference<U> ，这意味着我们希望接收U类型的元素作为输入，并将下游接收器传递给构造函数。因为下一阶段需要接收整数，所以我们必须在向下游发出值时调用accept( int )方法。 accept()方法将映射函数从U应用到int并将结果值传递给下游Sink 。</p></blockquote><p>最终Sink在最后被excute执行，完成了Stream流一系列操作</p><h1 id="使用Stream"><a href="#使用Stream" class="headerlink" title="使用Stream"></a>使用Stream</h1><p>Stream是惰性流，中间操作实际是存储lambda函数，终端操作是把这个链表的方法执行。<br>Stream分为中间操作和终端操作，我们分开来说。</p><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><p>中间操作在源码层面上，就是创建一个继承ReferencePipeline的StatelessOp<br>在这里，我们使用样例，来进行更好的理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Stream&lt;String&gt; s = Stream.of(<span class="hljs-string">&quot;一-1&quot;</span>, <span class="hljs-string">&quot;二-2&quot;</span>, <span class="hljs-string">&quot;三-3&quot;</span>, <span class="hljs-string">&quot;四-4&quot;</span>, <span class="hljs-string">&quot;五-5&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>lambda函数可以是本对象的方法，还可以是静态用到参数的，或者自己定的</p></blockquote><p>我们先分析Stream，它规范了很多接口，其中用于使用的中间操作如下:</p><ul><li><p>Stream<T> filter(Predicate&lt;? super T&gt; predicate);<br>传入的lambda函数返回bool值，用来进行筛选，不多解释</p></li><li><p>map 系列相关的：</p></li><li><p>Stream<R> map(Function&lt;? super T, ? extends R&gt; mapper); lambda函数返回值不做要求，结果转化为新流</p></li><li><p>IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper); lambda函数返回值需要为int类型，结果转化为新流</p></li><li><p>LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper); lambda函数返回值需要为long类型，结果转化为新流</p></li><li><p>DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper); lambda函数返回值需要为double类型，结果转化为新流<br>也好理解些，难理解的在后面</p></li><li><p>flatMap 系列：</p></li><li><p>Stream<R> flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper); 返回值需要继承Stream，它可以遍历流元素，并形成新的流进行处理</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">s.flatMap(r -&gt; Arrays.stream(r.split(<span class="hljs-string">&quot;-&quot;</span>)).map(r2 -&gt; r2 + <span class="hljs-string">&quot;空格&quot;</span>)).forEach(System.out::println);<br></code></pre></td></tr></table></figure></li><li><p>IntStream flatMapToInt(Function&lt;? super T, ? extends IntStream&gt; mapper); 返回值需要继承IntStream，它可以遍历流元素，并形成新的流进行处理</p></li><li><p>LongStream flatMapToLong(Function&lt;? super T, ? extends LongStream&gt; mapper); 返回值需要继承LongStream，它可以遍历流元素，并形成新的流进行处理</p></li><li><p>DoubleStream flatMapToDouble(Function&lt;? super T, ? extends DoubleStream&gt; mapper);  返回值需要继承DoubleStream，它可以遍历流元素，并形成新的流进行处理</p></li><li></li><li><p>Stream<T> distinct(); 用来去重</p></li><li><p>sort() &#x2F; sort(comparator) 用来比较，并排序</p></li><li><p>Stream<T> limit(long maxSize); 用来缩小范围</p></li><li><p>Stream<T> skip(long n); 用来跳过区间</p></li><li><p>Stream<T> peek(Consumer&lt;? super T&gt; action); 类似forEach，但是只有在最后执行（本身如此）</p></li></ul><h2 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h2><ul><li><p>forEach系列</p></li><li><p>void forEach(Consumer&lt;? super T&gt; action); 对流的每个元素执行一个操作</p></li><li><p>void forEachOrdered(Consumer&lt;? super T&gt; action); 如流可以有顺序，则先进行顺序处理</p></li><li><p>reduce 系列</p></li><li><p>T reduce(T identity, BinaryOperator<T> accumulator); &#x2F;&#x2F; 累加器</p></li><li><p>Optional<T> reduce(BinaryOperator<T> accumulator);</p></li><li><p>U reduce(U identity,BiFunction, ? super T, U&gt; accumulator, BinaryOperator combiner);</p></li><li><p>collect 系列</p></li><li><p>R collect(Supplier supplier,BiConsumer&lt;R, ? super T&gt; accumulator,BiConsumer&lt;R, R&gt; combiner);</p></li><li><p>R collect(Collector&lt;? super T, A, R&gt; collector); &#x2F;&#x2F;Collector里有可以转化的方式</p></li><li><p>Optional<T> min(Comparator&lt;? super T&gt; comparator); &#x2F;&#x2F;最小的那个</p></li><li><p>Optional<T> max(Comparator&lt;? super T&gt; comparator); &#x2F;&#x2F;最大的那个</p></li><li><p>long count(); &#x2F;&#x2F;统计数量</p></li><li><p>boolean anyMatch(Predicate&lt;? super T&gt; predicate); &#x2F;&#x2F;是否存在一个匹配</p></li><li><p>boolean allMatch(Predicate&lt;? super T&gt; predicate); &#x2F;&#x2F;是否全部匹配</p></li><li><p>boolean noneMatch(Predicate&lt;? super T&gt; predicate); &#x2F;&#x2F;是否没有匹配</p></li><li><p>Optional<T> findFirst(); &#x2F;&#x2F;找到第一个，并返回</p></li><li><p>Optional<T> findAny(); &#x2F;&#x2F;找到就行，并返回</p></li><li><p>toArray() 转化为Array</p></li><li><p>toList() 转化为List</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文分析了Stream的创建，结构和使用，当然重点在使用，可以提高操作Collection的效率</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用go写jvm之线程共享的运行时数据区</title>
      <link href="/2023/05/28/%E7%94%A8go%E5%86%99jvm%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
      <url>/2023/05/28/%E7%94%A8go%E5%86%99jvm%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>在本节，我们将实现线程共享的运行时数据区，包括方法区和运行时常量池</p><span id="more"></span><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>它是运行时数据区的一块逻辑区域，由多个线程共享，主要存放从class文件获取的类信息，另外类变量也存放在方法区中。</p><h3 id="class相关结构体"><a href="#class相关结构体" class="headerlink" title="class相关结构体"></a>class相关结构体</h3><p>我们首先实现类结构体和类成员结构体，</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// Class 定义类结构体</span><br><span class="hljs-keyword">type</span> Class <span class="hljs-keyword">struct</span> &#123;<br>accessFlags       <span class="hljs-type">uint16</span>                  <span class="hljs-comment">//访问标志</span><br>name              <span class="hljs-type">string</span>                  <span class="hljs-comment">//类名，完全限定名</span><br>superClassName    <span class="hljs-type">string</span>                  <span class="hljs-comment">//超类名</span><br>interfaceNames    []<span class="hljs-type">string</span>                <span class="hljs-comment">//接口名</span><br>constantPool      *classfile.ConstantPool <span class="hljs-comment">//运行时常量池指针</span><br>fields            []*Field                <span class="hljs-comment">//字段表</span><br>methods           []*Method               <span class="hljs-comment">//方法表</span><br>loader            *ClassLoader            <span class="hljs-comment">//读取类数据的类加载器</span><br>superClass        *Class                  <span class="hljs-comment">//超类</span><br>interfaces        []*Class                <span class="hljs-comment">//接口</span><br>instanceSlotCount <span class="hljs-type">uint</span>                    <span class="hljs-comment">//实例变量占据的空间大小</span><br>staticSlotCount   <span class="hljs-type">uint</span>                    <span class="hljs-comment">//静态变量占据的空间大小</span><br>staticVars        Slots                  <span class="hljs-comment">//静态变量</span><br>&#125;<br><span class="hljs-comment">// 类成员，包括字段和方法</span><br><span class="hljs-keyword">type</span> ClassMember <span class="hljs-keyword">struct</span> &#123;<br>accessFlags <span class="hljs-type">uint16</span> <span class="hljs-comment">//访问标志</span><br>name        <span class="hljs-type">string</span> <span class="hljs-comment">//名字</span><br>descriptor  <span class="hljs-type">string</span> <span class="hljs-comment">//标志</span><br>class       *Class <span class="hljs-comment">//所属类</span><br>&#125;<br><span class="hljs-comment">// Field 字段</span><br><span class="hljs-keyword">type</span> Field <span class="hljs-keyword">struct</span> &#123;<br>ClassMember<br>&#125;<br><span class="hljs-comment">// Method 方法</span><br><span class="hljs-keyword">type</span> Method <span class="hljs-keyword">struct</span> &#123;<br>ClassMember<br>maxStack  <span class="hljs-type">uint</span>   <span class="hljs-comment">// 操作数栈的最大深度</span><br>maxLocals <span class="hljs-type">uint</span>   <span class="hljs-comment">// 局部变量表大小</span><br>code      []<span class="hljs-type">byte</span> <span class="hljs-comment">// 字节码</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-keyword">type</span> ConstantPool <span class="hljs-keyword">struct</span> &#123;<br>class  *Class<br>consts []Constant<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newConstantPool</span><span class="hljs-params">(class *Class, cfCp classfile.ConstantPool)</span></span> *ConstantPool &#123;<br><span class="hljs-comment">// 将class文件中的常量池，转换为运行时常量池</span><br>cpCount := <span class="hljs-built_in">len</span>(cfCp)<br>consts := <span class="hljs-built_in">make</span>([]Constant, cpCount)<br>rtCp := &amp;ConstantPool&#123;class, consts&#125;<br><br><span class="hljs-comment">// cp的引用类型，继承关系如下:</span><br><span class="hljs-comment">// symref -&gt; classRef</span><br><span class="hljs-comment">//  -&gt; memberRef</span><br><span class="hljs-comment">//-&gt; fieldRef</span><br><span class="hljs-comment">//-&gt; methodRef</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; cpCount; i++ &#123;<br><span class="hljs-comment">// 获取常量池信息</span><br>cpInfo := cfCp[i]<br><span class="hljs-keyword">switch</span> cpInfo.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *classfile.ConstantIntegerInfo:<br><span class="hljs-comment">// 整数</span><br>intInfo := cpInfo.(*classfile.ConstantIntegerInfo)<br>consts[i] = intInfo.Value()<br><span class="hljs-keyword">case</span> *classfile.ConstantFloatInfo:<br><span class="hljs-comment">// 浮点数</span><br>floatInfo := cpInfo.(*classfile.ConstantFloatInfo)<br>consts[i] = floatInfo.Value()<br><span class="hljs-keyword">case</span> *classfile.ConstantLongInfo:<br><span class="hljs-comment">// 长整数，因为占两个位置，所以需要跳过一个位置</span><br>longInfo := cpInfo.(*classfile.ConstantLongInfo)<br>consts[i] = longInfo.Value()<br>i++<br><span class="hljs-keyword">case</span> *classfile.ConstantDoubleInfo:<br><span class="hljs-comment">// 双精度浮点数，因为占两个位置，所以需要跳过一个位置</span><br>doubleInfo := cpInfo.(*classfile.ConstantDoubleInfo)<br>consts[i] = doubleInfo.Value()<br>i++<br><span class="hljs-keyword">case</span> *classfile.ConstantStringInfo:<br><span class="hljs-comment">// 字符串字面量</span><br>stringInfo := cpInfo.(*classfile.ConstantStringInfo)<br>consts[i] = stringInfo.Name()<br><span class="hljs-keyword">case</span> *classfile.ConstantClassInfo:<br><span class="hljs-comment">// 类符号引用</span><br>classInfo := cpInfo.(*classfile.ConstantClassInfo)<br>consts[i] = newClassRef(rtCp, classInfo)<br><span class="hljs-keyword">case</span> *classfile.ConstantFieldrefInfo:<br><span class="hljs-comment">// 字段符号引用</span><br>fieldrefInfo := cpInfo.(*classfile.ConstantFieldrefInfo)<br>consts[i] = newFieldRef(rtCp, fieldrefInfo)<br><span class="hljs-keyword">case</span> *classfile.ConstantMethodrefInfo:<br><span class="hljs-comment">// 方法符号引用</span><br>methodrefInfo := cpInfo.(*classfile.ConstantMethodrefInfo)<br>consts[i] = newMethodRef(rtCp, methodrefInfo)<br><span class="hljs-keyword">case</span> *classfile.ConstantInterfaceMethodrefInfo:<br><span class="hljs-comment">// 接口方法符号引用</span><br>methodrefInfo := cpInfo.(*classfile.ConstantInterfaceMethodrefInfo)<br>consts[i] = newInterfaceMethodRef(rtCp, methodrefInfo)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> rtCp<br>&#125;<br></code></pre></td></tr></table></figure><p>对应classFile中的常量池中元素类型，我们转换其相应的类型，<br>分为字面量和引用，字面量包括整数、浮点数、长整数、双精度浮点数、字符串字面量，引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号引用。</p><p>举例如方法符号引用：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// SymRef 符号引用</span><br><span class="hljs-keyword">type</span> SymRef <span class="hljs-keyword">struct</span> &#123;<br>cp        *ConstantPool <span class="hljs-comment">// 常量池，运行时常量指针</span><br>className <span class="hljs-type">string</span>        <span class="hljs-comment">// 类名，完全限定名</span><br>class     *Class        <span class="hljs-comment">// 类</span><br>&#125;<br><br><span class="hljs-comment">// MemberRef 字段符号引用和方法符号引用共有的信息</span><br><span class="hljs-keyword">type</span> MemberRef <span class="hljs-keyword">struct</span> &#123;<br>SymRef<br>name       <span class="hljs-type">string</span> <span class="hljs-comment">// 字段名</span><br>descriptor <span class="hljs-type">string</span> <span class="hljs-comment">// 字段描述符，代表在java虚拟机的角度，一个类可以有多个同名字段</span><br>&#125;<br><span class="hljs-comment">// copyMemberRefInfo()方法从classfile.MemberInfo结构体中复制数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *MemberRef)</span></span> copyMemberRefInfo(memberInfo *classfile.ConstantMemberrefInfo) &#123;<br>self.className = memberInfo.ClassName()<br>self.name, self.descriptor = memberInfo.NameAndDescriptor()<br>&#125;<br><br><span class="hljs-comment">// MethodRef 方法符号引用</span><br><span class="hljs-keyword">type</span> MethodRef <span class="hljs-keyword">struct</span> &#123;<br>MemberRef<br>method *Method<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newMethodRef</span><span class="hljs-params">(cp *ConstantPool, refInfo *classfile.ConstantMethodrefInfo)</span></span> *MethodRef &#123;<br>ref := &amp;MethodRef&#123;&#125;<br>ref.cp = cp<br>ref.copyMemberRefInfo(&amp;refInfo.ConstantMemberrefInfo)<br><span class="hljs-keyword">return</span> ref<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器，用来读取class文件、解析class、验证和准备class，<br>分别使用classpath,classfile，相当于再次走一遍过程即可。</p><p>重点说一下验证和准备class:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><br><span class="hljs-comment">// 链接，进行验证和准备</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">link</span><span class="hljs-params">(class *Class)</span></span> &#123;<br><span class="hljs-comment">// 对类进行严格验证</span><br>verify(class)<br><span class="hljs-comment">// 准备阶段，给类变量分配空间并给予初始值</span><br>prepare(class)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">verify</span><span class="hljs-params">(class *Class)</span></span> &#123;<br><span class="hljs-comment">// todo</span><br>&#125;<br><br><span class="hljs-comment">// prepare 准备阶段，给类变量分配空间并给予初始值</span><br><span class="hljs-comment">// 从上一个类的实例变量个数开始，给类的实例变量分配空间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">prepare</span><span class="hljs-params">(class *Class)</span></span> &#123;<br>calcInstanceFieldSlotIds(class)<br>calcStaticFieldSlotIds(class)<br>allocAndInitStaticVars(class)<br>&#125;<br><br><span class="hljs-comment">// 计算类的实例字段变量个数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calcInstanceFieldSlotIds</span><span class="hljs-params">(class *Class)</span></span> &#123;<br>slotId := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> class.superClass != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 等于超类的实例变量个数</span><br>slotId = class.superClass.instanceSlotCount<br>&#125;<br><span class="hljs-keyword">for</span> _, field := <span class="hljs-keyword">range</span> class.fields &#123;<br><span class="hljs-keyword">if</span> !field.IsStatic() &#123;<br>field.slotId = slotId<br>slotId++<br><span class="hljs-keyword">if</span> field.isLongOrDouble() &#123;<br>field.slotId++<br>&#125;<br>&#125;<br>&#125;<br>class.instanceSlotCount = slotId<br>&#125;<br><br><span class="hljs-comment">// 计算类的静态变量个数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calcStaticFieldSlotIds</span><span class="hljs-params">(class *Class)</span></span> &#123;<br>slotId := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> _, field := <span class="hljs-keyword">range</span> class.fields &#123;<br><span class="hljs-keyword">if</span> field.IsStatic() &#123;<br>field.slotId = slotId<br>slotId++<br><span class="hljs-keyword">if</span> field.isLongOrDouble() &#123;<br>slotId++<br>&#125;<br>&#125;<br>&#125;<br>class.staticSlotCount = slotId<br>&#125;<br><br><span class="hljs-comment">// 给类变量分配空间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">allocAndInitStaticVars</span><span class="hljs-params">(class *Class)</span></span> &#123;<br><span class="hljs-comment">// 给类变量分配空间</span><br>class.staticVars = newSlots(class.staticSlotCount)<br><span class="hljs-comment">// 给类变量赋予初始值</span><br><span class="hljs-keyword">for</span> _, field := <span class="hljs-keyword">range</span> class.fields &#123;<br><span class="hljs-comment">// 给静态变量复制，从常量池中加载常量值</span><br><span class="hljs-keyword">if</span> field.IsStatic() &amp;&amp; field.IsFinal() &#123;<br>initStaticFinalVar(class, field)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 给静态变量赋予初始值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initStaticFinalVar</span><span class="hljs-params">(class *Class, field *Field)</span></span> &#123;<br><span class="hljs-comment">// 获取静态变量表</span><br>vars := class.staticVars<br><span class="hljs-comment">// 获取常量池</span><br>cp := class.constantPool<br><span class="hljs-comment">// 获取常量值索引</span><br>cpIndex := field.ConstValueIndex()<br><span class="hljs-comment">// 获取静态变量索引</span><br>slotId := field.SlotId()<br><br><span class="hljs-keyword">if</span> cpIndex &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">switch</span> field.descriptor &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Z&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;S&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>:<br><span class="hljs-comment">// 获取int类型的常量值</span><br>val := cp.GetConstant(cpIndex).(<span class="hljs-type">int32</span>)<br><span class="hljs-comment">// 给静态变量赋值</span><br>vars.SetInt(slotId, val)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;J&quot;</span>:<br><span class="hljs-comment">// 获取long类型的常量值</span><br>val := cp.GetConstant(cpIndex).(<span class="hljs-type">int64</span>)<br><span class="hljs-comment">// 给静态变量赋值</span><br>vars.SetLong(slotId, val)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;F&quot;</span>:<br><span class="hljs-comment">// 获取float类型的常量值</span><br>val := cp.GetConstant(cpIndex).(<span class="hljs-type">float32</span>)<br><span class="hljs-comment">// 给静态变量赋值</span><br>vars.SetFloat(slotId, val)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;D&quot;</span>:<br><span class="hljs-comment">// 获取double类型的常量值</span><br>val := cp.GetConstant(cpIndex).(<span class="hljs-type">float64</span>)<br><span class="hljs-comment">// 给静态变量赋值</span><br>vars.SetDouble(slotId, val)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>:<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;todo&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类和类成员引用"><a href="#类和类成员引用" class="headerlink" title="类和类成员引用"></a>类和类成员引用</h3><p>实现ResolvedClass和ResolvedMemberRef接口，用来表示类和类成员引用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// ResolvedClass 类符号引用解析</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *SymRef)</span></span> ResolvedClass() *Class &#123;<br><span class="hljs-comment">// 如果已经解析过了，就不解析了</span><br><span class="hljs-keyword">if</span> self.class == <span class="hljs-literal">nil</span> &#123;<br>self.resolveClassRef()<br>&#125;<br><span class="hljs-keyword">return</span> self.class<br>&#125;<br><span class="hljs-comment">// resolveClassRef 类符号引用解析</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *SymRef)</span></span> resolveClassRef() &#123;<br>d := self.cp.class                      <span class="hljs-comment">// 使用当前主类的类加载器</span><br>c := d.loader.LoadClass(self.className) <span class="hljs-comment">// 加载类</span><br><span class="hljs-comment">// 类的访问控制规则</span><br><span class="hljs-keyword">if</span> !c.isAccessibleTo(d) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;java.lang.IllegalAccessError&quot;</span>)<br>&#125;<br>self.class = c<br>&#125;<br></code></pre></td></tr></table></figure><p>如果类已经解析过了，就不解析了。解析类时，应进行类的访问控制规则判断，只有符合规则的类才能被访问。<br>类似，我们实现字段引用</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// FieldRef 定义字段引用</span><br><span class="hljs-keyword">type</span> FieldRef <span class="hljs-keyword">struct</span> &#123;<br>MemberRef<br>field *Field <span class="hljs-comment">//指向属性</span><br>&#125;<br><br><span class="hljs-comment">// ResolvedField 字段符号引用解析</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *FieldRef)</span></span> ResolvedField() *Field &#123;<br><span class="hljs-keyword">if</span> self.field == <span class="hljs-literal">nil</span> &#123;<br>self.resolvedFieldRef()<br>&#125;<br><span class="hljs-keyword">return</span> self.field<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *FieldRef)</span></span> resolvedFieldRef() &#123;<br>d := self.cp.class<br>c := self.ResolvedClass()<br><span class="hljs-comment">// 查找字段</span><br>field := lookupField(c, self.name, self.descriptor)<br><br><span class="hljs-keyword">if</span> field == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;java.lang.NoSuchFieldError&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 判断字段是否可以访问</span><br><span class="hljs-keyword">if</span> !field.isAccessibleTo(d) &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;java.lang.IllegalAccessError&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// lookupField 查找字段</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lookupField</span><span class="hljs-params">(class *Class, name, descriptor <span class="hljs-type">string</span>)</span></span> *Field &#123;<br><span class="hljs-comment">// 先在当前类中查找</span><br><span class="hljs-keyword">for</span> _, field := <span class="hljs-keyword">range</span> class.fields &#123;<br><span class="hljs-keyword">if</span> field.name == name &amp;&amp; field.descriptor == descriptor &#123;<br><span class="hljs-keyword">return</span> field<br>&#125;<br>&#125;<br><span class="hljs-comment">// 在接口中查找</span><br><span class="hljs-keyword">for</span> _, iface := <span class="hljs-keyword">range</span> class.interfaces &#123;<br><span class="hljs-keyword">if</span> field := lookupField(iface, name, descriptor); field != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> field<br>&#125;<br>&#125;<br><span class="hljs-comment">// 在父类中查找</span><br><span class="hljs-keyword">if</span> class.superClass != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> lookupField(class.superClass, name, descriptor)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 访问控制规则</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *Field)</span></span> isAccessibleTo(d *Class) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// 如果是public，就是任意访问</span><br><span class="hljs-keyword">if</span> self.IsPublic() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>c := self.class<br><br><span class="hljs-comment">// 如果是protected, 就是同一个类，子类，同一个包</span><br><span class="hljs-keyword">if</span> self.IsProtected() &#123;<br><span class="hljs-keyword">return</span> d == c || d.isSubClassOf(c) || c.getPackageName() == d.getPackageName()<br>&#125;<br><br><span class="hljs-comment">// 如果是private, 就是同一个类</span><br><span class="hljs-keyword">if</span> self.IsPrivate() &#123;<br><span class="hljs-keyword">return</span> d == c<br>&#125;<br><br><span class="hljs-keyword">return</span> c.getPackageName() == d.getPackageName()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果字段已经解析了，就不解析了。<br>解析字段的时候，先进行查找字段，查询字段所属类是否存在字段，然后查询其父类和接口是否存在字段。<br>最后进行字段的访问控制规则判断，只有符合规则的字段才能被访问。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本篇，我们实现了类的结构体，以及其相关的属性。<br>常量池将class文件的常量池转换而来，常量池存储常量数值和符号引用。<br>方法表与字段表存储对应的类成员信息，静态变量存储静态变量。<br>当然我们也做了classLoader的实现，实现了类的加载，解析，初始化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 项目 </tag>
            
            <tag> JVM </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用go写jvm之指令集和解释器</title>
      <link href="/2023/05/27/%E7%94%A8go%E5%86%99jvm%E4%B9%8B%E6%8C%87%E4%BB%A4%E9%9B%86%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
      <url>/2023/05/27/%E7%94%A8go%E5%86%99jvm%E4%B9%8B%E6%8C%87%E4%BB%A4%E9%9B%86%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Java虚拟机规范，把定义的205条指令按用途分成11类，<br>分别是常量constants指令，加载loads指令，存储stores指令，操作数stack指令，数学math指令，转换conversions指令，比较comparisons指令，控制control指令，引用references指令，扩展extended指令和保留reserved指令。</p><p>在本节，我们将实现大部分指令集和解释器</p><span id="more"></span><h3 id="指令集部分"><a href="#指令集部分" class="headerlink" title="指令集部分"></a>指令集部分</h3><p>为读取字节码，我们创建指令接口用于读取和执行</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// Instruction 指令接口</span><br><span class="hljs-keyword">type</span> Instruction <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// FetchOperands 从字节码中提取操作数</span><br>FetchOperands(reader *BytecodeReader)<br><span class="hljs-comment">// Execute 执行指令逻辑</span><br>Execute(frame *rtda.Frame)<br>&#125;<br><br><span class="hljs-comment">// NoOperandsInstruction 无操作数指令</span><br><span class="hljs-keyword">type</span> NoOperandsInstruction <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i NoOperandsInstruction)</span></span> FetchOperands(reader *BytecodeReader) &#123;<br><span class="hljs-comment">// noting to do</span><br>&#125;<br><br><span class="hljs-comment">// BranchInstruction 跳转指令</span><br><span class="hljs-keyword">type</span> BranchInstruction <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 跳转偏移量</span><br>Offset <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *BranchInstruction)</span></span> FetchOperands(reader *BytecodeReader) &#123;<br><span class="hljs-comment">// 从字节码中读取一个uint16整数</span><br>self.Offset = <span class="hljs-type">int</span>(reader.ReadInt16())<br>&#125;<br><br><span class="hljs-comment">// Index8Instruction 读取一个uint8整数</span><br><span class="hljs-keyword">type</span> Index8Instruction <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 局部变量表索引</span><br>Index <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *Index8Instruction)</span></span> FetchOperands(reader *BytecodeReader) &#123;<br>self.Index = <span class="hljs-type">uint</span>(reader.ReadUint8())<br>&#125;<br><br><span class="hljs-comment">// Index16Instruction 读取一个uint16整数</span><br><span class="hljs-keyword">type</span> Index16Instruction <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 局部变量索引</span><br>Index <span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *Index16Instruction)</span></span> FetchOperands(reader *BytecodeReader) &#123;<br>self.Index = <span class="hljs-type">uint</span>(reader.ReadUint16())<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们分别定义了基本指令接口，无操作数指令，跳转指令，读取一个uint8整数指令和读取一个uint16整数指令。</p><p>然后根据上面定义的结构体，拓展更多指令，在这里我们就不详细说了，具体代码看<a href="https://github.com/TRO148/TroJvm/tree/master/instructions">这里</a></p><blockquote><p>在这里我们简要分析一些指令:</p><p>_const系列指令：<br>_const系列指令用于将常量推入操作数栈顶，包括null指令，int指令，float指令，long指令，double指令和aconst_null指令。<br>直接使用栈帧中操作栈的推入，即可完成对应的指令</p><p>_store系列指令：<br>_store系列指令用于将操作数栈顶的值存入局部变量表，包括istore指令，lstore指令，fstore指令，dstore指令，astore指令和istore_n指令。<br>直接使用栈帧中局部变量表的存储，即可完成对应的指令</p><p>_load系列指令：<br>_load系列指令用于将局部变量表的值推入操作数栈顶，包括iload指令，lload指令，fload指令，dload指令，aload指令和iload_n指令。<br>直接使用栈帧中局部变量表的读取，即可完成对应的指令</p><p>stack系指令:<br>dup:复制栈顶数值并将复制值压入栈顶，并区分dup和dup_x1，dup_x2，dup2，dup2_x1，dup2_x2，用来使复制值放入不同的顺序之中。<br>通过弹出对应的变量，然后再推入一定顺序的变量来实现操作。</p><p>control系列指令:<br>control系列指令用于控制程序流程，包括goto指令，tableswitch指令和lookupswitch指令。通过改变pc，来实现跳转。</p></blockquote><h3 id="解释器部分"><a href="#解释器部分" class="headerlink" title="解释器部分"></a>解释器部分</h3><p>在这里，我们实现解释器方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// Interpret 解释器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Interpret</span><span class="hljs-params">(methodInfo *classfile.MemberInfo)</span></span> &#123;<br>codeAttr := methodInfo.CodeAttribute()<br><span class="hljs-comment">// 局部属性表最大索引</span><br>maxLocals := codeAttr.MaxLocals()<br><span class="hljs-comment">// 操作栈深度</span><br>maxStack := codeAttr.MaxStack()<br>bytecode := codeAttr.Code()<br><br><span class="hljs-comment">//创建一个Thread实例，创建帧并推入虚拟机栈顶，然后执行方法</span><br>thread := rtda.NewThread()<br>frame := thread.NewFrame(maxLocals, maxStack)<br>thread.PushFrame(frame)<br><br><span class="hljs-keyword">defer</span> catchErr(frame)<br>loop(thread, bytecode)<br>&#125;<br><br><span class="hljs-comment">// CatchErr 报错</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">catchErr</span><span class="hljs-params">(frame *rtda.Frame)</span></span> &#123;<br><span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;LocalVars:%v\n&quot;</span>, frame.LocalVars())<br>fmt.Printf(<span class="hljs-string">&quot;OperandStack:%v\n&quot;</span>, frame.OperandStack())<br><span class="hljs-built_in">panic</span>(r)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Loop 循环</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loop</span><span class="hljs-params">(thread *rtda.Thread, bytecode []<span class="hljs-type">byte</span>)</span></span> &#123;<br>frame := thread.PopFrame()<br>reader := &amp;base.BytecodeReader&#123;&#125;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">//计算pc</span><br>pc := frame.NextPC()<br>thread.SetPc(pc)<br><br><span class="hljs-comment">//解码指令</span><br>reader.Reset(bytecode, pc)<br>opcode := reader.ReadUint8()<br>inst := instructions.NewInstruction(opcode)<br>inst.FetchOperands(reader)<br>frame.SetNextPC(reader.PC())<br><br><span class="hljs-comment">//执行指令</span><br>fmt.Printf(<span class="hljs-string">&quot;pc:%2d inst:%T %v\n&quot;</span>, pc, inst, inst)<br>inst.Execute(frame)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为在jvm中code存放在方法属性中，所以我们需要先从方法属性中读取code属性，然后创建一个Thread实例，创建帧并推入虚拟机栈顶，然后执行方法。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startJVM</span><span class="hljs-params">(cmd *Cmd)</span></span> &#123;<br>cp := classpath.Parse(cmd.XjreOption, cmd.cpOption)<br>className := strings.Replace(cmd.class, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">-1</span>)<br>cf := loadClass(className, cp)<br>mainMethod := getMainMethod(cf)<br><span class="hljs-keyword">if</span> mainMethod != <span class="hljs-literal">nil</span> &#123;<br>interpreter.Interpret(mainMethod)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Main method not found in class %s\n&quot;</span>, cmd.class)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadClass</span><span class="hljs-params">(className <span class="hljs-type">string</span>, cp *classpath.ClassPath)</span></span> *classfile.ClassFile &#123;<br>classData, _, err := cp.ReadClass(className)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>cf, err := classfile.Parse(classData)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-keyword">return</span> cf<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMainMethod</span><span class="hljs-params">(cf *classfile.ClassFile)</span></span> *classfile.MemberInfo &#123;<br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> cf.Methods() &#123;<br><span class="hljs-keyword">if</span> m.Name() == <span class="hljs-string">&quot;main&quot;</span> &amp;&amp; m.Descriptor() == <span class="hljs-string">&quot;([Ljava/lang/String;)V&quot;</span> &#123;<br><span class="hljs-keyword">return</span> m<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们先解析class文件，然后获取main方法，解析main方法的字节码，然后查看数据</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>暂时的，我们实现了解释器和大部分指令集的功能，并通过NewInstruction方法，根据不同的指令创建不同的指令实例，这样就可以通过指令实例来执行指令了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 项目 </tag>
            
            <tag> JVM </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用go写jvm之运行时数据区</title>
      <link href="/2023/05/26/%E7%94%A8go%E5%86%99jvm%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
      <url>/2023/05/26/%E7%94%A8go%E5%86%99jvm%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>在运行Java程序时，Java虚拟机需要使用内存来存放各式各样的数据。Java虚拟机规范把这些内存区域叫做运行时数据区。</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>运行时数据区分为：一类是多线程共享的，另一类则是线程私有的。</p><blockquote><p>多线程共享的内存区域：<br>主要存放类数据和类实例，对象数据存放在堆Heap，类数据存放在方法区Method Area。<br>堆由垃圾收集器定期清理。<br>类数据包括字段和方法信息、方法的字节码、运行时常量池等。</p><p>线程私有的运行时数据区：<br>主要用来辅助执行Java字节码。每个线程都有字节的pc寄存器和Java虚拟机栈(JVM Stack)。<br>Java虚拟机栈又由栈帧组成，帧中保存方法执行的状态，包括局部变量表和操作数栈等。</p><p>在任一时刻，某一线程在执行某个方法，这个方法叫做当前方法，执行方法的帧叫做线程的当前帧，声明该方法的类叫做当前类。 </p></blockquote><h2 id="实现线程私有运行时数据区"><a href="#实现线程私有运行时数据区" class="headerlink" title="实现线程私有运行时数据区"></a>实现线程私有运行时数据区</h2><p>在这里，我们先实现线程私有运行时数据区，大致思路为创建pc和虚拟栈，其中栈帧包含局部变量表和操作数栈。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// Thread 线程</span><br><span class="hljs-comment">// 每个线程都有一个pc寄存器和Java虚拟机栈</span><br><span class="hljs-keyword">type</span> Thread <span class="hljs-keyword">struct</span> &#123;<br>pc    <span class="hljs-type">int</span>    <span class="hljs-comment">//pc寄存器</span><br>stack *Stack <span class="hljs-comment">//Java虚拟机栈的指针</span><br>&#125;<br><br><span class="hljs-comment">// Stack 栈</span><br><span class="hljs-keyword">type</span> Stack <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 最大容量</span><br>maxSize <span class="hljs-type">uint</span><br><span class="hljs-comment">// 当前大小</span><br>size <span class="hljs-type">uint</span><br><span class="hljs-comment">// 栈顶</span><br>_top *Frame<br>&#125;<br><br><span class="hljs-keyword">type</span> Frame <span class="hljs-keyword">struct</span> &#123;<br>lower        *Frame        <span class="hljs-comment">//下一个栈帧</span><br>localVars    LocalVars     <span class="hljs-comment">//局部变量表，使用[]Slot实现</span><br>operandStack *OperandStack <span class="hljs-comment">//操作数栈，也使用[]Slot实现</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="讨论局部变量表和操作数栈"><a href="#讨论局部变量表和操作数栈" class="headerlink" title="讨论局部变量表和操作数栈"></a>讨论局部变量表和操作数栈</h3><p>局部变量表和操作数栈的元素，需要至少表示一个int或引用值，用来存放数据。<br>如果只用一个int，引用值不能存放，会被垃圾回收清理掉，用[]interface{}表示太过繁琐。<br>所以，我们使用Slot来表示局部变量表和操作数栈的元素，Slot是一个结构体，包含int和引用值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// Slot 局部变量，用来实现局部变量表</span><br><span class="hljs-keyword">type</span> Slot <span class="hljs-keyword">struct</span> &#123;<br>num <span class="hljs-type">int32</span>   <span class="hljs-comment">//存放整数，将基础变量类型转换成int32类型</span><br>ref *Object <span class="hljs-comment">//存放引用，将引用类型转换成*Object类型</span><br>&#125;<br><br><span class="hljs-comment">// LocalVars 局部变量表</span><br><span class="hljs-keyword">type</span> LocalVars []Slot<br><br><span class="hljs-comment">// OperandStack 操作数栈</span><br><span class="hljs-keyword">type</span> OperandStack <span class="hljs-keyword">struct</span> &#123;<br>size  <span class="hljs-type">uint</span>   <span class="hljs-comment">//栈顶位置</span><br>slots []Slot <span class="hljs-comment">//栈</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><p>在这里，我们的局部变量表和操作数栈用来存放数据，根据不同类型，采用不同存放方式。</p><p>对于java虚拟栈，我们需要实现push和pop方法，用来入栈和出栈。</p><p>代码详见<a href="https://github.com/TRO148/TroJvm/tree/master/rtda">这里</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这里，我们实现了线程私有的运行时数据区，包括pc寄存器和Java虚拟机栈，其中Java虚拟机栈由栈帧组成，栈帧包含局部变量表和操作数栈。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 项目 </tag>
            
            <tag> JVM </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用go写jvm之解析class文件</title>
      <link href="/2023/05/26/%E7%94%A8go%E5%86%99jvm%E4%B9%8B%E8%A7%A3%E6%9E%90class%E6%96%87%E4%BB%B6/"/>
      <url>/2023/05/26/%E7%94%A8go%E5%86%99jvm%E4%B9%8B%E8%A7%A3%E6%9E%90class%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在搜索到class文件后，得到字节码数据，然后将它解析为class文件结构</p><span id="more"></span><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><p>分析class文件结构，可以发现它主要是由以下部分组成：</p><ul><li>魔数、版本号、访问标志、类索引、父类索引</li><li>常量池</li><li>字段表、方法表</li><li>属性表<br>据此建立class文件结构体，然后将字节码数据解析为结构体。<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-keyword">type</span> ClassFile <span class="hljs-keyword">struct</span> &#123;<br>minorVersion <span class="hljs-type">uint16</span> <span class="hljs-comment">// 次版本号</span><br>majorVersion <span class="hljs-type">uint16</span> <span class="hljs-comment">// 主版本号</span><br><br>constantPool ConstantPool <span class="hljs-comment">// 常量池</span><br><br>accessFlags <span class="hljs-type">uint16</span> <span class="hljs-comment">// 访问标志</span><br>thisClass   <span class="hljs-type">uint16</span> <span class="hljs-comment">// 类索引</span><br>superClass  <span class="hljs-type">uint16</span> <span class="hljs-comment">// 父类索引</span><br><br>interfaces []<span class="hljs-type">uint16</span> <span class="hljs-comment">// 接口索引表</span><br><br>fields  []*MemberInfo <span class="hljs-comment">// 字段表</span><br>methods []*MemberInfo <span class="hljs-comment">// 方法表</span><br><br>attributes []AttributeInfo <span class="hljs-comment">// 属性表</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="解析Class"><a href="#解析Class" class="headerlink" title="解析Class"></a>解析Class</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// Parse 解析class文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(classData []<span class="hljs-type">byte</span>)</span></span> (cf *ClassFile, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// defer + recover做到异常捕获</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 尝试恢复，如果恢复成功，将err赋值为恢复的错误</span><br><span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">var</span> ok <span class="hljs-type">bool</span><br>err, ok = r.(<span class="hljs-type">error</span>) <span class="hljs-comment">// 类型断言</span><br><span class="hljs-keyword">if</span> !ok &#123;<br>err = fmt.Errorf(<span class="hljs-string">&quot;%v&quot;</span>, r)<br>&#125;<br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// 读取数据</span><br>cr := &amp;ClassReader&#123;classData&#125;<br>cf = &amp;ClassFile&#123;&#125;<br><br><span class="hljs-comment">// 装填数据</span><br>cf.read(cr)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// read 读取</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *ClassFile)</span></span> read(reader *ClassReader) &#123;<br>self.readAndCheckMagic(reader)               <span class="hljs-comment">// 读取并检查魔数</span><br>self.readAndCheckVersion(reader)             <span class="hljs-comment">// 读取并检查版本号</span><br>self.constantPool = readConstantPool(reader) <span class="hljs-comment">// 读取常量池</span><br><br>self.accessFlags = reader.readUint16() <span class="hljs-comment">// 读取访问标志</span><br>self.thisClass = reader.readUint16()   <span class="hljs-comment">// 读取类索引</span><br>self.superClass = reader.readUint16()  <span class="hljs-comment">// 读取父类索引</span><br>self.interfaces = reader.readUint16s() <span class="hljs-comment">// 读取接口索引表</span><br><br>self.fields = readMembers(reader, self.constantPool)        <span class="hljs-comment">// 读取字段表</span><br>self.methods = readMembers(reader, self.constantPool)       <span class="hljs-comment">// 读取方法表</span><br>self.attributes = readAttributes(reader, self.constantPool) <span class="hljs-comment">// 读取属性表</span><br>&#125;<br></code></pre></td></tr></table></figure><p>模拟tryCatch，然后读取数据，根据class文件的字节码顺序，进行读取，将数据存储在classfile中。</p><h2 id="分析常量池"><a href="#分析常量池" class="headerlink" title="分析常量池"></a>分析常量池</h2><p>常量池，是存储常量（Constant_Info）的表，读取常量池大小，然后读取常量。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// ConstantPool 常量池，常量的表</span><br><span class="hljs-keyword">type</span> ConstantPool []ConstantInfo<br><br><span class="hljs-comment">// readConstantPool 读取常量池</span><br><span class="hljs-comment">// 需要注意的是表头给出的常量大小比实际大1</span><br><span class="hljs-comment">// 0是无效索引，不指向任何常量</span><br><span class="hljs-comment">// CONSTANT_Long_info和CONSTANT_Double_info各占两个位置，实际常量数量比n-1还小</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readConstantPool</span><span class="hljs-params">(reader *ClassReader)</span></span> ConstantPool &#123;<br><span class="hljs-comment">// 读取常量池大小</span><br>cpCount := <span class="hljs-type">int</span>(reader.readUint16())<br><span class="hljs-comment">// 生成常量池</span><br>cp := <span class="hljs-built_in">make</span>([]ConstantInfo, cpCount)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; cpCount; i++ &#123;<br>cp[i] = readConstantInfo(reader, cp)<br><span class="hljs-comment">// 根据类型进行操作</span><br><span class="hljs-keyword">switch</span> cp[i].(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *ConstantLongInfo, *ConstantDoubleInfo:<br>i++<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> cp<br>&#125;<br></code></pre></td></tr></table></figure><p>读取常量部分，采用不同类型，进行不同操作，生成不同常量</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// ConstantInfo 定义常量信息接口</span><br><span class="hljs-keyword">type</span> ConstantInfo <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// 读取常量信息</span><br>readInfo(reader *ClassReader)<br>&#125;<br><span class="hljs-comment">// readConstantInfo 读取常量信息</span><br><span class="hljs-comment">// 先读出tag值，创建具体的常量，最后调用常量的readInfo()方法读取常量信息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readConstantInfo</span><span class="hljs-params">(reader *ClassReader, cp ConstantPool)</span></span> ConstantInfo &#123;<br><span class="hljs-comment">// 读出什么类型的</span><br>tag := reader.readUint8()<br><span class="hljs-comment">// 创建常量</span><br>c := newConstantInfo(tag, cp)<br><span class="hljs-comment">// 读取常量信息</span><br>c.readInfo(reader)<br><span class="hljs-keyword">return</span> c<br>&#125;<br><span class="hljs-comment">// newConstantInfo 生成常量信息</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newConstantInfo</span><span class="hljs-params">(tag <span class="hljs-type">uint8</span>, cp ConstantPool)</span></span> ConstantInfo &#123;<br><span class="hljs-keyword">switch</span> tag &#123;<br><span class="hljs-keyword">case</span> CONSTANT_Integer:<br><span class="hljs-keyword">return</span> &amp;ConstantIntegerInfo&#123;&#125;<br><span class="hljs-keyword">case</span> CONSTANT_Float:<br><span class="hljs-keyword">return</span> &amp;ConstantFloatInfo&#123;&#125;<br><span class="hljs-keyword">case</span> CONSTANT_Long:<br><span class="hljs-keyword">return</span> &amp;ConstantLongInfo&#123;&#125;<br><span class="hljs-keyword">case</span> CONSTANT_Double:<br><span class="hljs-keyword">return</span> &amp;ConstantDoubleInfo&#123;&#125;<br><span class="hljs-keyword">case</span> CONSTANT_Utf8:<br><span class="hljs-keyword">return</span> &amp;ConstantUtf8Info&#123;&#125;<br><span class="hljs-keyword">case</span> CONSTANT_String:<br><span class="hljs-keyword">return</span> &amp;ConstantStringInfo&#123;cp: cp&#125;<br><span class="hljs-keyword">case</span> CONSTANT_Class:<br><span class="hljs-keyword">return</span> &amp;ConstantClassInfo&#123;cp: cp&#125;<br><span class="hljs-keyword">case</span> COMSTANT_Fieldref:<br><span class="hljs-keyword">return</span> &amp;ConstantFieldrefInfo&#123;ConstantMemberrefInfo&#123;cp: cp&#125;&#125;<br><span class="hljs-keyword">case</span> CONSTANT_Methodref:<br><span class="hljs-keyword">return</span> &amp;ConstantMethodrefInfo&#123;ConstantMemberrefInfo&#123;cp: cp&#125;&#125;<br><span class="hljs-keyword">case</span> CONSTANT_InterfaceMethodref:<br><span class="hljs-keyword">return</span> &amp;ConstantInterfaceMethodrefInfo&#123;ConstantMemberrefInfo&#123;cp: cp&#125;&#125;<br><span class="hljs-keyword">case</span> CONSTANT_NameAndType:<br><span class="hljs-keyword">return</span> &amp;ConstantNameAndTypeInfo&#123;&#125;<br><span class="hljs-comment">// 目的解析invokedynamic指令</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;java.lang.ClassFormatError: constant pool tag!&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于不同的常量处理过程，详见<a href="https://github.com/TRO148/TroJvm/tree/master/classfile">这里</a></p><h2 id="解析字段和方法表"><a href="#解析字段和方法表" class="headerlink" title="解析字段和方法表"></a>解析字段和方法表</h2><p>由于字段表和方法表采用相同的结构，所以采用相同的方法进行解析。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// MemberInfo 字段和方法表</span><br><span class="hljs-keyword">type</span> MemberInfo <span class="hljs-keyword">struct</span> &#123;<br>cp              ConstantPool    <span class="hljs-comment">// 常量池</span><br>accessFlags     <span class="hljs-type">uint16</span>          <span class="hljs-comment">//访问标志</span><br>nameIndex       <span class="hljs-type">uint16</span>          <span class="hljs-comment">//常量池索引,给出字段名或方法名</span><br>descriptorIndex <span class="hljs-type">uint16</span>          <span class="hljs-comment">//常量池索引,给出字段或方法描述符</span><br>attributes      []AttributeInfo <span class="hljs-comment">//属性表</span><br>&#125;<br><br><span class="hljs-comment">// readMembers 生成读取字段表和方法表的函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readMembers</span><span class="hljs-params">(reader *ClassReader, cp ConstantPool)</span></span> []*MemberInfo &#123;<br><span class="hljs-comment">// 读取字段表或方法表的成员数量</span><br>memberCount := reader.readUint16()<br><span class="hljs-comment">// 生成字段表或方法表</span><br>members := <span class="hljs-built_in">make</span>([]*MemberInfo, memberCount)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> members &#123;<br>members[i] = readMember(reader, cp)<br>&#125;<br><span class="hljs-keyword">return</span> members<br>&#125;<br><br><span class="hljs-comment">// 辅助函数 readMember 用来读取字段或方法数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readMember</span><span class="hljs-params">(reader *ClassReader, cp ConstantPool)</span></span> *MemberInfo &#123;<br><span class="hljs-comment">// 依次读取数据</span><br><span class="hljs-keyword">return</span> &amp;MemberInfo&#123;<br>cp:              cp,<br>accessFlags:     reader.readUint16(),        <span class="hljs-comment">// 访问标志</span><br>nameIndex:       reader.readUint16(),        <span class="hljs-comment">// 名称索引</span><br>descriptorIndex: reader.readUint16(),        <span class="hljs-comment">// 描述符索引</span><br>attributes:      readAttributes(reader, cp), <span class="hljs-comment">// 属性表</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解析属性表"><a href="#解析属性表" class="headerlink" title="解析属性表"></a>解析属性表</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// AttributeInfo 属性信息接口</span><br><span class="hljs-comment">// 按照用户，23种预定义属性可分为三组，第一组是实现Java虚拟机所必需的，共有5种；第二组是Java类库所必需的，共有12种；第三组是可选的，共有6种。</span><br><span class="hljs-keyword">type</span> AttributeInfo <span class="hljs-keyword">interface</span> &#123;<br>readInfo(reader *ClassReader)<br>&#125;<br><br><span class="hljs-comment">// readAttributes 读取属性表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readAttributes</span><span class="hljs-params">(reader *ClassReader, cp ConstantPool)</span></span> []AttributeInfo &#123;<br><span class="hljs-comment">// 读取属性表长度</span><br>attributesCount := reader.readUint16()<br><span class="hljs-comment">// 创建属性表</span><br>attributes := <span class="hljs-built_in">make</span>([]AttributeInfo, attributesCount)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> attributes &#123;<br>attributes[i] = readAttribute(reader, cp)<br>&#125;<br><span class="hljs-keyword">return</span> attributes<br>&#125;<br><br><span class="hljs-comment">// readAttribute 读取属性</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readAttribute</span><span class="hljs-params">(reader *ClassReader, cp ConstantPool)</span></span> AttributeInfo &#123;<br><span class="hljs-comment">// 读取属性名索引</span><br>attrNameIndex := reader.readUint16()<br><span class="hljs-comment">// 在常量池中查询属性名</span><br>attrName := cp.getUtf8(attrNameIndex)<br><span class="hljs-comment">// 读取属性长度</span><br>attrLen := reader.readUint32()<br><span class="hljs-comment">// 创建属性信息</span><br>attrInfo := newAttributeInfo(attrName, attrLen, cp)<br><span class="hljs-comment">// 读取属性信息reader</span><br>attrInfo.readInfo(reader)<br><span class="hljs-keyword">return</span> attrInfo<br>&#125;<br><br><span class="hljs-comment">// newAttributeInfo 创建属性信息 23种属性</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newAttributeInfo</span><span class="hljs-params">(attrName <span class="hljs-type">string</span>, attrLen <span class="hljs-type">uint32</span>, cp ConstantPool)</span></span> AttributeInfo &#123;<br><span class="hljs-keyword">switch</span> attrName &#123;<br><br><span class="hljs-comment">// 标识的</span><br><span class="hljs-comment">// Deprecated是最简单的属性之一，仅起到标记作用，不包含任何数据，可出现在ClassFile、field_info和method_info结构中。</span><br><span class="hljs-comment">// Deprecated 用于表示不建议使用的属性，可以在java中使用@Deprecated标签指出编译器给出警告信息。</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Deprecated&quot;</span>:<br><span class="hljs-keyword">return</span> &amp;DeprecatedAttribute&#123;&#125;<br><span class="hljs-comment">// Synthetic也是最简单的属性之一，起到标识作用，不包含任何数据，可出现在ClassFile、field_info和method_info结构中。</span><br><span class="hljs-comment">// Synthetic 用于标记源文件中不存在、由编译器生成的类成员，引入Synthetic属性主要是为了支持嵌套类和嵌套接口。</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Synthetic&quot;</span>:<br><span class="hljs-keyword">return</span> &amp;SyntheticAttribute&#123;&#125;<br><br><span class="hljs-comment">// 编译器生成的</span><br><span class="hljs-comment">// SourceFile是可选定长属性，只会出现在ClassFile结构中，用于指出源文件名。</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;SourceFile&quot;</span>:<br><span class="hljs-keyword">return</span> &amp;SourceFileAttribute&#123;cp: cp&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;LineNumberTable&quot;</span>:<br><span class="hljs-keyword">return</span> &amp;LineNumberTableAttribute&#123;&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;LocalVariableTable&quot;</span>:<br><span class="hljs-keyword">return</span> &amp;LocalVariableTableAttribute&#123;&#125;<br><br><span class="hljs-comment">// 存放信息</span><br><span class="hljs-comment">// ConstantValue是定长属性，只会出现在field_info结构中，用于表示常量表达式的值。</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ConstantValue&quot;</span>:<br><span class="hljs-keyword">return</span> &amp;ConstantValueAttribute&#123;&#125;<br><span class="hljs-comment">// Code是变长属性，只会出现在method_info结构中，用于存放字节码等方法相关信息。</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Code&quot;</span>:<br><span class="hljs-keyword">return</span> &amp;CodeAttribute&#123;cp: cp&#125;<br><span class="hljs-comment">// Exceptions是变长属性，用于指出方法抛出的异常表。</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Exceptions&quot;</span>:<br><span class="hljs-keyword">return</span> &amp;ExceptionsAttribute&#123;&#125;<br><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> &amp;UnparsedAttribute&#123;attrName, attrLen, <span class="hljs-literal">nil</span>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先读取属性表，然后再读每一个属性，根据属性名，创建属性信息，然后读取属性信息。</p><p>具体属性信息也详见<a href="https://github.com/TRO148/TroJvm/tree/master/classfile">这里</a></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>解析class文件部分，基本就是使用reader，读取固定长度的字节，获取相应的信息，并组成不同的信息结构，这里就不再赘述了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 项目 </tag>
            
            <tag> JVM </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用go写jvm之搜索class文件</title>
      <link href="/2023/05/23/%E7%94%A8go%E5%86%99jvm%E4%B9%8B%E6%90%9C%E7%B4%A2class%E6%96%87%E4%BB%B6/"/>
      <url>/2023/05/23/%E7%94%A8go%E5%86%99jvm%E4%B9%8B%E6%90%9C%E7%B4%A2class%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>java虚拟机首先要做的事情就是搜索class文件，这里我们用go来实现搜索class文件的功能。</p><span id="more"></span><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>Oracle的Java虚拟机根据类路径来搜索类，<br>我们可以创建类路径，存储类路径项。</p><blockquote><p>类路径可以分为启动类路径，扩展类路径，用户类路径<br>类路径项可以分为普通Entry，目录Entry，压缩包或JarEntry，复合Entry</p></blockquote><h2 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// ClassPath 结构体，存放三种类路径</span><br><span class="hljs-keyword">type</span> ClassPath <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 启动类路径</span><br>bootClasspath Entry<br><span class="hljs-comment">// 扩展类路径</span><br>extClasspath Entry<br><span class="hljs-comment">// 用户类路径</span><br>userClasspath Entry<br>&#125;<br><br><span class="hljs-comment">// Parse 解析类路径</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(jreOption, cpOption <span class="hljs-type">string</span>)</span></span> *ClassPath &#123;<br>cp := &amp;ClassPath&#123;&#125;<br><span class="hljs-comment">// 解析启动类路径和扩展类路径</span><br>cp.parseBootAndExtClasspath(jreOption)<br><span class="hljs-comment">// 解析用户类路径</span><br>cp.parseUserClasspath(cpOption)<br><br><span class="hljs-keyword">return</span> cp<br>&#125;<br><br><span class="hljs-comment">// parseBootAndExtClasspath 解析启动类路径和扩展类路径</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *ClassPath)</span></span> parseBootAndExtClasspath(jreOption <span class="hljs-type">string</span>) &#123;<br><span class="hljs-comment">// 对jre目录进行判断</span><br>jreDir := getJreDir(jreOption)<br><br><span class="hljs-comment">// jre/lib/* 解析启动类路径</span><br>jreLibPath := filepath.Join(jreDir, <span class="hljs-string">&quot;lib&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)<br>self.bootClasspath = newWildcardEntry(jreLibPath)<br><br><span class="hljs-comment">// jre/lib/ext/* 解析扩展类路径</span><br>jreExtPath := filepath.Join(jreDir, <span class="hljs-string">&quot;lib&quot;</span>, <span class="hljs-string">&quot;ext&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)<br>self.extClasspath = newWildcardEntry(jreExtPath)<br>&#125;<br><br><span class="hljs-comment">// 辅助函数 getJreDir 获取jre目录</span><br><span class="hljs-comment">// 优先使用用户输入-Xjre选项作为jre目录，</span><br><span class="hljs-comment">// 如果没有，就用当前目录下的jre目录，如果找不到，就尝试使用JAVA_HOME环境变量</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getJreDir</span><span class="hljs-params">(jreOption <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> jreOption != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; exists(jreOption) &#123;<br><span class="hljs-keyword">return</span> jreOption<br>&#125;<br><span class="hljs-keyword">if</span> exists(<span class="hljs-string">&quot;./jre&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;./jre&quot;</span><br>&#125;<br><span class="hljs-keyword">if</span> jh := os.Getenv(<span class="hljs-string">&quot;JAVA_HOME&quot;</span>); jh != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> filepath.Join(jh, <span class="hljs-string">&quot;jre&quot;</span>)<br>&#125;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;找不到jre目录！&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 辅助函数 exists 判断文件是否存在</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exists</span><span class="hljs-params">(path <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// 如果返回的错误为nil，说明文件或者目录存在</span><br><span class="hljs-keyword">if</span> _, err := os.Stat(path); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 再次确认错误类型是否为不存在，还是其他</span><br><span class="hljs-keyword">if</span> os.IsNotExist(err) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// parseUserClasspath 解析用户类路径</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *ClassPath)</span></span> parseUserClasspath(cpOption <span class="hljs-type">string</span>) &#123;<br><span class="hljs-comment">// 如果用户没有提供-classpath/-cp选项，则使用当前目录作为用户类路径</span><br><span class="hljs-keyword">if</span> cpOption == <span class="hljs-string">&quot;&quot;</span> &#123;<br>cpOption = <span class="hljs-string">&quot;.&quot;</span><br>&#125;<br>self.userClasspath = newEntry(cpOption)<br>&#125;<br><br><span class="hljs-comment">// ReadClass 读取</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *ClassPath)</span></span> ReadClass(className <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, Entry, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 将类名转换为相对路径</span><br>className = className + <span class="hljs-string">&quot;.class&quot;</span><br><span class="hljs-comment">// 依次从启动类路径、扩展类路径和用户类路径中搜索class文件</span><br><span class="hljs-keyword">if</span> data, entry, err := self.bootClasspath.readClass(className); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> data, entry, err<br>&#125;<br><span class="hljs-keyword">if</span> data, entry, err := self.extClasspath.readClass(className); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> data, entry, err<br>&#125;<br><span class="hljs-keyword">return</span> self.userClasspath.readClass(className)<br>&#125;<br><br><span class="hljs-comment">// String 转化为字符串</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(self *ClassPath)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> self.userClasspath.String()<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们实现了类路径的解析，以及读取class文件的功能。</p><h3 id="分析类路径解析部分"><a href="#分析类路径解析部分" class="headerlink" title="分析类路径解析部分"></a>分析类路径解析部分</h3><blockquote><p>通过jreOption与cpOption来解析类路径，jreOption是-Xjre选项，cpOption是-classpath&#x2F;-cp选项。</p><p>启动类与拓展类使用jreOption，它们是lib或lib&#x2F;ext目录下的所有类，<br>所以首先采用通配符Entry生成，将目录全部分析，然后再向下不断分析。<br>注意的是，我们应该先对Jre目录进行判断，先看jreOption是否存在，如果不存在，再看当前目录下是否存在jre目录，如果还是不存在，再看JAVA_HOME环境变量是否存在，如果还是不存在，就抛出异常。</p><p>cpOption是用户类路径，如果用户没有提供-classpath&#x2F;-cp选项，则使用当前目录作为用户类路径。</p></blockquote><h3 id="分析读取class文件部分"><a href="#分析读取class文件部分" class="headerlink" title="分析读取class文件部分"></a>分析读取class文件部分</h3><blockquote><p>读取class文件，首先将类名转换为相对路径，然后依次从启动类路径、扩展类路径和用户类路径中搜索class文件。</p></blockquote><h2 id="类路径项"><a href="#类路径项" class="headerlink" title="类路径项"></a>类路径项</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// Entry 接口</span><br><span class="hljs-keyword">const</span> pathListSeparator = <span class="hljs-type">string</span>(os.PathListSeparator)<br><br><span class="hljs-comment">// Entry 类路径项</span><br><span class="hljs-comment">// 举例作用：假设要读取java.lang.Object类，传入参数应该是java/lang/Object.class，</span><br><span class="hljs-comment">// 返回读取到的字节数据，最终定位到class文件的Entry</span><br><span class="hljs-keyword">type</span> Entry <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// readClass 用来寻找和加载class文件</span><br>readClass(className <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, Entry, <span class="hljs-type">error</span>)<br><span class="hljs-comment">// String 类似返回变量的字符串表示</span><br>String() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// newEntry 创建新的Entry</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newEntry</span><span class="hljs-params">(path <span class="hljs-type">string</span>)</span></span> Entry &#123;<br><span class="hljs-comment">// 如果包含分隔符，说明是复合Entry</span><br><span class="hljs-comment">// 例如: java -cp a.jar;b.jar;c.jar; com.example.Main</span><br><span class="hljs-keyword">if</span> strings.Contains(path, pathListSeparator) &#123;<br><span class="hljs-keyword">return</span> newCompositeEntry(path)<br>&#125;<br><br><span class="hljs-comment">// 如果是*结尾，说明是通配符Entry</span><br><span class="hljs-comment">// 例如: java -cp * com.example.Main</span><br><span class="hljs-keyword">if</span> strings.HasSuffix(path, <span class="hljs-string">&quot;*&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> newWildcardEntry(path)<br>&#125;<br><br><span class="hljs-comment">// 如果是zip或者jar包，说明是zip或者jar包Entry</span><br><span class="hljs-comment">// 例如: java -cp a.jar com.example.Main</span><br><span class="hljs-keyword">if</span> strings.HasSuffix(path, <span class="hljs-string">&quot;.jar&quot;</span>) || strings.HasSuffix(path, <span class="hljs-string">&quot;.JAR&quot;</span>) ||<br>strings.HasSuffix(path, <span class="hljs-string">&quot;.zip&quot;</span>) || strings.HasSuffix(path, <span class="hljs-string">&quot;.ZIP&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> newZipEntry(path)<br>&#125;<br><br><span class="hljs-comment">// 否则是目录Entry</span><br><span class="hljs-comment">// 例如: java -cp com/example Main</span><br><span class="hljs-keyword">return</span> newDirEntry(path)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://github.com/TRO148/TroJvm/tree/master/classpath">其他Entry实现在TRO148&#x2F;TroJvm中</a></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Golang">   cp := classpath.Parse(XjreOption, cpOption)<br><span class="hljs-comment">// 把.全部替换成/</span><br>className := strings.Replace(cmd.class, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">-1</span>)<br>classData, _, err := cp.ReadClass(className)<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>就这样，我们完成了类路径的解析，以及读取class文件的功能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 项目 </tag>
            
            <tag> JVM </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gin的中间件原理简单实现</title>
      <link href="/2023/05/19/gin%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/05/19/gin%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>通过向添加handlers中间件，并按顺序执行，实现中间件</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先在上下文中添加属性中间件链，记录当前执行到第几个中间件的属性。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 原生的参数</span><br>Writer  http.ResponseWriter<br>Request *http.Request<br><br><span class="hljs-comment">// 请求信息</span><br>Path   <span class="hljs-type">string</span><br>Method <span class="hljs-type">string</span><br>Params <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br><br><span class="hljs-comment">// 响应信息</span><br>StatusCode <span class="hljs-type">int</span><br><br><span class="hljs-comment">//中间件</span><br>handlers []HandlerFunc<br><span class="hljs-comment">// index 用于记录当前执行到第几个中间件</span><br>index <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后在Context中添加Next方法，用于执行下一个中间件</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// Next 向下执行中间件</span><br><span class="hljs-comment">// 当中间件调用Next()的时候，向后执行，然后再回来</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Next() &#123;<br>c.index++<br>s := <span class="hljs-built_in">len</span>(c.handlers)<br><span class="hljs-keyword">for</span> ; c.index &lt; s; c.index++ &#123;<br>c.handlers[c.index](c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么要在Context设置中间件相关的属性?</p><p>因为Context是每个请求的上下文，每个请求都有自己的处理函数链，所以需要在Context中设置中间件相关的属性</p></blockquote><p>因为在分组中，中间件才能发挥到真正的作用，所以在分组中也添加相关属性</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// routerGroup 分组，提供引擎的基本方法</span><br><span class="hljs-keyword">type</span> routerGroup <span class="hljs-keyword">struct</span> &#123;<br>prefix      <span class="hljs-type">string</span>        <span class="hljs-comment">//前缀</span><br>middlewares []HandlerFunc <span class="hljs-comment">//中间件，用于特殊处理</span><br>parent      *routerGroup  <span class="hljs-comment">//父组</span><br>engine      *Engine       <span class="hljs-comment">//所有分组使用同一个引擎</span><br>&#125;<br><br><span class="hljs-comment">// Use 添加中间件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *routerGroup)</span></span> Use(middlewares ...HandlerFunc) &#123;<br>group.middlewares = <span class="hljs-built_in">append</span>(group.middlewares, middlewares...)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就可以给分组添加中间件啦。<br>在运行时，我们应该先处理分组中的中间件，然后再运行本身的调用函数，当然这些已经在上下文中实现，<br>我们只需要给上下文添加调用函数链，然后调用上下文即可。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// ServeHTTP 用于ListenAndServe调用，实现ServeHTTP接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br><span class="hljs-keyword">var</span> middlewares []HandlerFunc<br><span class="hljs-keyword">for</span> _, group := <span class="hljs-keyword">range</span> engine.groups &#123;<br><span class="hljs-keyword">if</span> strings.HasPrefix(req.URL.Path, group.prefix) &#123;<br><span class="hljs-comment">//装填所有有关的中间件</span><br>middlewares = <span class="hljs-built_in">append</span>(middlewares, group.middlewares...)<br>&#125;<br>&#125;<br>c := newContext(w, req)<br><span class="hljs-comment">// 赋值，用来调用Next()时，调用中间件，将组和上下文关联起来</span><br>c.handlers = middlewares<br><span class="hljs-comment">// 调用路由的处理函数</span><br>engine.r.handle(c)<br>&#125;<br><br><span class="hljs-comment">// handle 处理请求，根据请求方法+请求路径，从map中取出对应的处理函数，存入Context中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;<br>n, params := r.getRoute(c.Method, c.Path)<br><span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;<br>c.Params = params<br>key := c.Method + <span class="hljs-string">&quot;-&quot;</span> + n.pattern<br>c.handlers = <span class="hljs-built_in">append</span>(c.handlers, r.handlers[key])<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.handlers = <span class="hljs-built_in">append</span>(c.handlers, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context *Context)</span></span> &#123;<br>context.String(<span class="hljs-number">404</span>, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, context.Path)<br>&#125;)<br>&#125;<br>c.Next()<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这样，我们就简单的实现了中间件。</p></blockquote><blockquote><p>大致就是这样的：调用路由处理函数时，将分组中的中间件添加到上下文中，然后调用上下文，执行中间件，最后执行路由处理函数。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习gin的路由树</title>
      <link href="/2023/05/18/%E5%AD%A6%E4%B9%A0gin%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A0%91/"/>
      <url>/2023/05/18/%E5%AD%A6%E4%B9%A0gin%E7%9A%84%E8%B7%AF%E7%94%B1%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>通过学习和写Gin的路由树，学习路由匹配知识</p><span id="more"></span><h2 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h2><p>通过创建路由节点，匹配子节点，插入与搜索节点，再搭配路由的插入与搜索，来实现路由。</p><h3 id="首先要创建路由节点，搭建好路由树的操作方法"><a href="#首先要创建路由节点，搭建好路由树的操作方法" class="headerlink" title="首先要创建路由节点，搭建好路由树的操作方法"></a>首先要创建路由节点，搭建好路由树的操作方法</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// 路由树节点，主要是树的操作，通过matchChild与matChildren搜索子节点，insert与search完成树基本操作</span><br><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;<br>pattern  <span class="hljs-type">string</span>  <span class="hljs-comment">//匹配路由</span><br>part     <span class="hljs-type">string</span>  <span class="hljs-comment">//路由中的一部分</span><br>children []*node <span class="hljs-comment">//子节点</span><br>isWild   <span class="hljs-type">bool</span>    <span class="hljs-comment">//是否精确匹配，part含有:或*时为true</span><br>&#125;<br><br><span class="hljs-comment">// matchChild 匹配子节点，返回第一个匹配成功的节点，用于插入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> matchChild(part <span class="hljs-type">string</span>) *node &#123;<br><span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> n.children &#123;<br><span class="hljs-comment">//如果子节点的part与要匹配的part相同，或者子节点的part为通配符，则返回该子节点</span><br><span class="hljs-keyword">if</span> child.part == part || child.isWild &#123;<br><span class="hljs-keyword">return</span> child<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// matchChildren 匹配子节点，返回所有匹配成功的节点，用于查找</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> matchChildren(part <span class="hljs-type">string</span>) []*node &#123;<br>nodes := <span class="hljs-built_in">make</span>([]*node, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> n.children &#123;<br><span class="hljs-comment">//如果子节点的part与要匹配的part相同，或者子节点的part为通配符，则返回该子节点</span><br><span class="hljs-keyword">if</span> child.part == part || child.isWild &#123;<br>nodes = <span class="hljs-built_in">append</span>(nodes, child)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> nodes<br>&#125;<br><br><span class="hljs-comment">// insert 插入节点，height说是第几层就是第几层，遇到没有的就自己填上，遇到有的就继续向下插入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> insert(pattern <span class="hljs-type">string</span>, parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height &#123; <span class="hljs-comment">//递归结束条件</span><br>n.pattern = pattern<br><span class="hljs-keyword">return</span><br>&#125;<br><br>part := parts[height]       <span class="hljs-comment">//获取当前层级的part</span><br>child := n.matchChild(part) <span class="hljs-comment">//获取当前层级的part对应的子节点</span><br><span class="hljs-keyword">if</span> child == <span class="hljs-literal">nil</span> &#123;<br>child = &amp;node&#123;part: part, isWild: part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> || part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span>&#125;<br>n.children = <span class="hljs-built_in">append</span>(n.children, child)<br>&#125;<br><br>child.insert(pattern, parts, height+<span class="hljs-number">1</span>) <span class="hljs-comment">//递归插入子节点</span><br>&#125;<br><br><span class="hljs-comment">// search 查询，不断匹配part，查询到路径的那个点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> search(parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) *node &#123;<br><span class="hljs-comment">//只要出现*，则不再进行后续搜索</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="hljs-string">&quot;*&quot;</span>) &#123; <span class="hljs-comment">//递归结束条件</span><br><span class="hljs-keyword">if</span> n.pattern == <span class="hljs-string">&quot;&quot;</span> &#123; <span class="hljs-comment">//如果当前节点的pattern为空，则说明没有匹配到</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> n<br>&#125;<br><br>part := parts[height]             <span class="hljs-comment">//获取当前层级的part</span><br>children := n.matchChildren(part) <span class="hljs-comment">//获取所有对应的子节点，包括*与:</span><br><br><span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> children &#123;<br>result := child.search(parts, height+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> result != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> result<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>通过matchChild与matchChildren完成基本的子节点搜索</p><p>在插入过程中，直至匹配到响应的层数，就进行插入操作，如果没有匹配到，则新建一个节点，然后继续插入</p><p>在搜索过程中，不断匹配part，直至匹配到最后一层，或者遇到*，则不再进行后续搜索</p></blockquote><h3 id="创建路由树，搭建好路由树的操作方法"><a href="#创建路由树，搭建好路由树的操作方法" class="headerlink" title="创建路由树，搭建好路由树的操作方法"></a>创建路由树，搭建好路由树的操作方法</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs Golang"><span class="hljs-comment">// Router 路由，用于存储路由信息</span><br><span class="hljs-keyword">type</span> Router <span class="hljs-keyword">struct</span> &#123;<br>roots    <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*node<br>handlers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc<br>&#125;<br><br><span class="hljs-comment">// parsePattern 解析路由，辅助函数，将pattern拆分parts</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePattern</span><span class="hljs-params">(pattern <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>vs := strings.Split(pattern, <span class="hljs-string">&quot;/&quot;</span>)<br><br><span class="hljs-comment">//所以不支持/*hi/hihi/hi,没有后续，只能到/*hi</span><br>parts := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> vs &#123;<br><span class="hljs-keyword">if</span> item != <span class="hljs-string">&quot;&quot;</span> &#123;<br>parts = <span class="hljs-built_in">append</span>(parts, item)<br><span class="hljs-keyword">if</span> item[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> parts<br>&#125;<br><br><span class="hljs-comment">// addRoute 添加路由，存入路由树与handlers方法中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(router *Router)</span></span> addRoute(method <span class="hljs-type">string</span>, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;<br>parts := parsePattern(pattern)<br><br><span class="hljs-comment">//存入节点，以方法为树的基本节点</span><br>_, ok := router.roots[method]<br><span class="hljs-keyword">if</span> !ok &#123;<br>router.roots[method] = &amp;node&#123;&#125;<br>&#125;<br>router.roots[method].insert(pattern, parts, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">//存入处理函数</span><br>key := method + <span class="hljs-string">&quot;-&quot;</span> + pattern<br>router.handlers[key] = handler<br>&#125;<br><br><span class="hljs-comment">// getRoute 获取路由，查询节点与参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(router *Router)</span></span> getRoute(method <span class="hljs-type">string</span>, path <span class="hljs-type">string</span>) (*node, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) &#123;<br>searchParts := parsePattern(path)<br>params := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><br>root, ok := router.roots[method]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">//查询到这个点</span><br>n := root.search(searchParts, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;<br>parts := parsePattern(n.pattern)<br><span class="hljs-keyword">for</span> index, part := <span class="hljs-keyword">range</span> parts &#123;<br><span class="hljs-comment">//如果为:，则添加到参数</span><br><span class="hljs-keyword">if</span> part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> &#123;<br>params[part[<span class="hljs-number">1</span>:]] = searchParts[index]<br>&#125;<br><span class="hljs-keyword">if</span> part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; <span class="hljs-built_in">len</span>(part) &gt; <span class="hljs-number">1</span> &#123;<br><span class="hljs-comment">//如果为*，把路径后续添加到参数</span><br>params[part[<span class="hljs-number">1</span>:]] = strings.Join(searchParts[index:], <span class="hljs-string">&quot;/&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> n, params<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// handle 处理请求，根据请求方法+请求路径，从map中取出对应的处理函数，执行</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(router *Router)</span></span> handle(c *Context) &#123;<br>n, params := router.getRoute(c.Method, c.Path)<br><span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;<br>c.Params = params<br>key := c.Method + <span class="hljs-string">&quot;-&quot;</span> + n.pattern<br>router.handlers[key](c)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c.String(http.StatusNotFound, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在创建路由树的时候，需要将路由树与handlers方法都存起来，路由树用于查询，handlers用于执行。</p></blockquote><h4 id="咳咳，内容较少，代码较多，逻辑还是比较清晰的"><a href="#咳咳，内容较少，代码较多，逻辑还是比较清晰的" class="headerlink" title="咳咳，内容较少，代码较多，逻辑还是比较清晰的"></a>咳咳，内容较少，代码较多，逻辑还是比较清晰的</h4>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解gRPC</title>
      <link href="/2023/05/04/%E4%BA%86%E8%A7%A3RPC/"/>
      <url>/2023/05/04/%E4%BA%86%E8%A7%A3RPC/</url>
      
        <content type="html"><![CDATA[<p>RPC是一种远程调用的方法，可以在不同的机器上调用函数，但是调用者不需要知道函数在哪个机器上，只需要知道函数名和参数即可。</p><span id="more"></span><p><strong>gRPC是RPC框架，接口描述语言是Protobuf(一种IDL)</strong></p><h1 id="1-简略一元RPC方式"><a href="#1-简略一元RPC方式" class="headerlink" title="1.简略一元RPC方式"></a>1.简略一元RPC方式</h1><ul><li><h3 id="首先写Proto文件，定义函数名和参数"><a href="#首先写Proto文件，定义函数名和参数" class="headerlink" title="首先写Proto文件，定义函数名和参数"></a>首先写Proto文件，定义函数名和参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs proto">syntax = &quot;proto3&quot;;<br><br>package helloWorld;<br><br>option go_package = &quot;./proto&quot;;<br><br>service Greeter &#123;<br>  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;<br>&#125;<br><br>message HelloRequest &#123;<br>  string name = 1;<br>&#125;<br><br>message HelloReply &#123;<br>  string message = 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>本Proto文件首先声明了使用proto3语法，定义了Greeter的RPC服务，<br>其中RPC的方法为SayHello，入参为消息体HelloRequest，出参为HelloReply，<br>还定义了这两个消息体。</p></li><li><h3 id="Server部分"><a href="#Server部分" class="headerlink" title="Server部分"></a>Server部分</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> port <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>flag.StringVar(&amp;port, <span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>, <span class="hljs-string">&quot;port to listen on&quot;</span>)<br>flag.Parse()<br>&#125;<br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span> &#123;<br>pb.UnimplementedGreeterServer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> SayHello(ctx context.Context, r *pb.HelloRequest) (*pb.HelloReply, <span class="hljs-type">error</span>) &#123;<br>fmt.Println(r.Name)<br><span class="hljs-keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="hljs-string">&quot;Hello &quot;</span> + r.Name&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//生成一个grpc服务器</span><br>s := grpc.NewServer()<br><span class="hljs-comment">//注入实例</span><br>pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)<br><br>lis, _ := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>+port)<br>err := s.Serve(lis)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li>创建了grpc Server端的抽象对象</li><li>然后将server（包含服务端接口）注入到s中</li><li>创建Listen监听TCP</li><li>s.Serve()开启服务</li></ul><ul><li><h3 id="Client部分"><a href="#Client部分" class="headerlink" title="Client部分"></a>Client部分</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> port <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>flag.StringVar(&amp;port, <span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8080&quot;</span>, <span class="hljs-string">&quot;port to listen on&quot;</span>)<br>flag.Parse()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SayHello</span><span class="hljs-params">(client pb.GreeterClient)</span></span> <span class="hljs-type">error</span> &#123;<br>resq, _ := client.SayHello(context.TODO(), &amp;pb.HelloRequest&#123;Name: <span class="hljs-string">&quot;world&quot;</span>&#125;)<br>fmt.Println(resq.Message)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//创建与服务端的连接句柄</span><br>conn, _ := grpc.Dial(<span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-comment">//创建客户端对象</span><br>client := pb.NewGreeterClient(conn)<br><span class="hljs-comment">//发出请求</span><br>_ = SayHello(client)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li>创建与服务端的连接句柄</li><li>创建客户端对象</li><li>发出请求</li></ul><blockquote><p>这样一元RPC就完成啦，分别配置好server（创建服务器，注入接口，启动监听开启服务器），client（连接句柄，创建客户端对象，发出请求）</p></blockquote><h1 id="2-流式RPC方式"><a href="#2-流式RPC方式" class="headerlink" title="2.流式RPC方式"></a>2.流式RPC方式</h1><blockquote><p>由于一元rpc可能会出现数据包过大造成瞬时压力，需要等待所有数据报接受成功才响应的问题，出现流式rpc</p><p>流式RPC使用stream关键字，分为客户端流式和服务端流式，还有双向流式</p></blockquote><p>直接说双向流式</p><ul><li><h3 id="首先写Proto文件，定义函数名和参数-1"><a href="#首先写Proto文件，定义函数名和参数-1" class="headerlink" title="首先写Proto文件，定义函数名和参数"></a>首先写Proto文件，定义函数名和参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs proto">rpc SayRoute (stream HelloRequest) returns (stream HelloReply) &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><h3 id="Server部分-1"><a href="#Server部分-1" class="headerlink" title="Server部分"></a>Server部分</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *server)</span></span> SayRoute(stream pb.Greeter_SayRouteServer) <span class="hljs-type">error</span> &#123;<br>n := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> &#123;<br>_ = stream.Send(&amp;pb.HelloReply&#123;Message: <span class="hljs-string">&quot;hi Route&quot;</span>&#125;)<br>r, err := stream.Recv()<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>n++<br><span class="hljs-built_in">println</span>(r.Name, n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h3 id="Client部分-1"><a href="#Client部分-1" class="headerlink" title="Client部分"></a>Client部分</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SayRoute</span><span class="hljs-params">(client pb.GreeterClient, r *pb.HelloRequest)</span></span> <span class="hljs-type">error</span> &#123;<br>stream, _ := client.SayRoute(context.Background())<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>_ = stream.Send(r)<br><br>fmt.Println(<span class="hljs-string">&quot;1&quot;</span>)<br>resp, err := stream.Recv()<br><br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>fmt.Println(resp.Message)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>stream.Send()和stream.Recv()分别是发送和接受数据，这里的消息体是HelloRequest和HelloReply。<br>stream.Send()和stream.Recv()是阻塞的，所以需要在另一个goroutine中执行</p></blockquote></li></ul><p>服务端流式类似，服务器使用stream.Send()发送数据，客户端使用stream.Recv()接受数据</p><p>客户端流式，客户端不断使用stream.Send()最后使用stream.CloseAndRecv(),服务器使用Recv()和SendAndRecv()</p><blockquote><p>gRPC暂时先写到这啦，现在对rpc没有什么需求，大致了解一下</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 云 </tag>
            
            <tag> Go </tag>
            
            <tag> Rpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解Gin</title>
      <link href="/2023/04/27/%E4%BA%86%E8%A7%A3Gin/"/>
      <url>/2023/04/27/%E4%BA%86%E8%A7%A3Gin/</url>
      
        <content type="html"><![CDATA[<p>Go的框架很多，gin是其中一个，通过研究gin的源代码，来了解gin的实现原理，以及gin的使用方法。</p><span id="more"></span><blockquote><p>Gin整体流程</p><p>gin.Default</p><p>gin.New</p><p>e.Get</p><p>e.Run</p><p>gin为包名，e为实例名</p></blockquote><h1 id="1-首先了解Engine与RouterGroup"><a href="#1-首先了解Engine与RouterGroup" class="headerlink" title="1.首先了解Engine与RouterGroup"></a>1.首先了解Engine与RouterGroup</h1><p>以下是Engine的结构体定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;<br>RouterGroup<br><span class="hljs-comment">//是否自动重定向</span><br>RedirectTrailingSlash <span class="hljs-type">bool</span><br><br><span class="hljs-comment">//是否支持格式清楚与不区分大小写重定向</span><br>RedirectFixedPath <span class="hljs-type">bool</span><br><br><span class="hljs-comment">//判断当前路由是否允许调用其他方法，是否可以返回Method Not Allowed和NotFound Handler</span><br>HandleMethodNotAllowed <span class="hljs-type">bool</span><br><br><span class="hljs-comment">//如果开启，尽可能返回真实客户端ip</span><br>ForwardedByClientIP <span class="hljs-type">bool</span><br><br><span class="hljs-comment">//当ForwardedByClientIP为true时，同时信任ip，存入X-Forwarded-For和X-Real-IP</span><br>RemoteIPHeaders []<span class="hljs-type">string</span><br><br><span class="hljs-comment">// If set to a constant of value gin.Platform*, trusts the headers set by</span><br><span class="hljs-comment">// that platform, for example to determine the client IP</span><br>TrustedPlatform <span class="hljs-type">string</span><br><br><span class="hljs-comment">// Value of &#x27;maxMemory&#x27; param that is given to http.Request&#x27;s ParseMultipartForm</span><br><span class="hljs-comment">// method call.</span><br>MaxMultipartMemory <span class="hljs-type">int64</span><br><br><span class="hljs-comment">// RemoveExtraSlash a parameter can be parsed from the URL even with extra slashes.</span><br><span class="hljs-comment">// See the PR #1817 and issue #1644</span><br>RemoveExtraSlash <span class="hljs-type">bool</span><br><br>delims           render.Delims<br>secureJSONPrefix <span class="hljs-type">string</span><br>HTMLRender       render.HTMLRender<br>FuncMap          template.FuncMap<br>allNoRoute       HandlersChain<br>allNoMethod      HandlersChain<br>noRoute          HandlersChain<br>noMethod         HandlersChain<br>pool             sync.Pool<br>trees            methodTrees<br>maxParams        <span class="hljs-type">uint16</span><br>maxSections      <span class="hljs-type">uint16</span><br>trustedProxies   []<span class="hljs-type">string</span><br>trustedCIDRs     []*net.IPNet<br>&#125;<br></code></pre></td></tr></table></figure><p>关键属性为RouterGroup，RouterGroup是一个结构体，定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RouterGroup <span class="hljs-keyword">struct</span> &#123;<br>Handlers HandlersChain<br>basePath <span class="hljs-type">string</span><br>engine   *Engine<br>root     <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过这两个关键结构体，来对gin进行全局设置</p><h1 id="2-了解gin-Default与gin-New"><a href="#2-了解gin-Default与gin-New" class="headerlink" title="2.了解gin.Default与gin.New"></a>2.了解gin.Default与gin.New</h1><p>由gin.Default方法可知:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Default</span><span class="hljs-params">()</span></span> *Engine &#123;<br>    debugPrintWARNINGDefault() <span class="hljs-comment">//打印警告信息</span><br>    engine := New() <span class="hljs-comment">//创建一个Engine</span><br>    engine.Use(Logger(), Recovery()) <span class="hljs-comment">//使用Logger和Recovery中间件</span><br>    <span class="hljs-keyword">return</span> engine<br>&#125;<br></code></pre></td></tr></table></figure><p>gin.Default方法中，调用了gin.New方法，而gin.New对整体的Engine进行了初始化.</p><blockquote><p>engine.Use(Logger(), Recovery())，把Logger和Recovery中间件添加到了Engine中HandlersChain中</p></blockquote><h1 id="3-e-GET"><a href="#3-e-GET" class="headerlink" title="3.e.GET"></a>3.e.GET</h1><p>gin的注册方法都使用handle：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// POST is a shortcut for router.Handle(&quot;POST&quot;, path, handle).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> POST(relativePath <span class="hljs-type">string</span>, handlers ...HandlerFunc) IRoutes &#123;<br><span class="hljs-keyword">return</span> group.handle(http.MethodPost, relativePath, handlers)<br>&#125;<br><span class="hljs-comment">// GET is a shortcut for router.Handle(&quot;GET&quot;, path, handle).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> GET(relativePath <span class="hljs-type">string</span>, handlers ...HandlerFunc) IRoutes &#123;<br><span class="hljs-keyword">return</span> group.handle(http.MethodGet, relativePath, handlers)<br>&#125;<br>····<br></code></pre></td></tr></table></figure><p>handler的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> handle(httpMethod, relativePath <span class="hljs-type">string</span>, handlers HandlersChain) IRoutes &#123;<br>absolutePath := group.calculateAbsolutePath(relativePath)<br>handlers = group.combineHandlers(handlers)<br>group.engine.addRoute(httpMethod, absolutePath, handlers)<br><span class="hljs-keyword">return</span> group.returnObj()<br>&#125;<br></code></pre></td></tr></table></figure><p>首先计算出绝对路径（基础路径+相对路径），然后合并当前的Handler，创建HandlersChain，添加当前注册的路由规则到路由树</p><blockquote><p>浅看一下gin的路由树添加规则:<br>gin给每一种请求方法都创建了一个路由树，每个路由树都是一个methodTree结构体<br>首先先找到路由树的根，判断这个根是否为空，如果为空，就创建一个根节点，然后将路由规则添加到根节点。</p></blockquote><h1 id="4-e-Run"><a href="#4-e-Run" class="headerlink" title="4.e.Run"></a>4.e.Run</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr ...<span class="hljs-type">string</span>) (err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; debugPrintError(err) &#125;()<br><br>    address := resolveAddress(addr)<br>    debugPrint(<span class="hljs-string">&quot;Listening and serving HTTP on %s\n&quot;</span>, address)<br>    err = http.ListenAndServe(address, engine)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此方法关键是使用了<strong>http.ListenAndServe</strong>方法，将Engine作为参数传入，然后监听端口，等待请求。<br>由于Engine实现了ServeHTTP方法，所以可以将Engine作为参数传入ListenAndServe方法中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br>c := engine.pool.Get().(*Context)<br>c.writermem.reset(w)<br>c.Request = req<br>c.reset()<br><br>engine.handleHTTPRequest(c)<br><br>engine.pool.Put(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>ServeHTTP方法中，首先从sync.Pool中获取一个Context， 然后将ResponseWriter和Request赋值给Context，<br>然后调用handleHTTPRequest方法处理外部HTTP请求，最后将Context放回sync.Pool中。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>gin的使用方法很简单，通过gin.Default()或者gin.New()创建一个Engine，然后通过Engine的GET、POST等方法注册路由规则，最后通过Engine的Run方法监听端口，等待请求。<br>gin重写了net&#x2F;http的route，通过ServeHTTP方法，将Engine作为参数传入ListenAndServe方法中，进行监听，通过自身的路由树匹配规则，来实现更快的响应。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2023/03/05/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/05/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Docker 是一个用于开发，交付和运行应用程序的开放平台。</p><span id="more"></span><p><em>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</em></p><h2 id="Docker容器使用"><a href="#Docker容器使用" class="headerlink" title="Docker容器使用"></a>Docker容器使用</h2><p>理解容器，它是从镜像中生成的一个容器，在这个容器之中，我们可以运行其中的项目</p><ul><li>启动容器 docker run xxxx</li><li>启动一个已停止的容器 docker start XXX</li><li>进入容器 docker attach xxx(退出容器会导致容器停止)&#x2F;docker exec xxx(退出容器不会导致容器停止)</li><li>退出容器 docker stop xxx</li><li>导出与导入容器 docker export xxx &gt; xxx &#x2F; docker import xxxx</li><li>删除容器docker rm -f xxx<br>Docker容器与宿主机的文件共享，可以使用-v参数，将宿主机的文件夹挂载到容器中，这样就可以实现容器与宿主机的文件共享，<br>也可以使用存储卷，将数据保存在本地，也可以保存在远程服务器上。</li></ul><h2 id="Docker镜像使用"><a href="#Docker镜像使用" class="headerlink" title="Docker镜像使用"></a>Docker镜像使用</h2><p>容器都是根据镜像产生的，可以从镜像仓库下载产生，也可以自己生成，镜像的使用可以提供一个完整的环境。</p><ul><li>docker images可以列出镜像</li><li>docker pull xxx获取新镜像</li><li>docker search 网络查找镜像</li><li>docker rmi xxx删除镜像</li><li>在某容器里使用apt-get update更新，在外docker commit -m 描述 -a 作者 容器id 目标镜像</li><li>docker tag可以给镜像上标签</li></ul><h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><p>实现容器互联，类似创造了一个网络，容器通过端口实现通信</p><ul><li>docker network create -d bridge网络类型 xxx 创造一个网络</li><li>docker network ls 展示所有网络</li><li>在运行容器的时候,–network xxx作为参数设置网络</li></ul><h2 id="Docker-Compose使用"><a href="#Docker-Compose使用" class="headerlink" title="Docker Compose使用"></a>Docker Compose使用</h2><p>通过Docker Compose方便管理Docker容器，准备好Docker-compose.yml</p><blockquote><p>yml配置参数为:<br>version版本<br>service：<br>  build：指定为构建镜像上下文路径或者对象（Dockerfile路径）<br>  其他参数看<a href="https://www.runoob.com/docker/docker-compose.html">这里</a></p></blockquote><p><strong>当然直接用portainer也可以嗷</strong><br><em>Partainer只需要安装一次即可，因为Partainer直接与Docker引擎交互，能够全局监控Docker的所有容器。</em></p><h2 id="Docker-Volume"><a href="#Docker-Volume" class="headerlink" title="Docker Volume"></a>Docker Volume</h2><p>docker存储卷，由于容器的生命周期是短暂的，容器内的数据也会随之消失，所以需要使用存储卷，可以将数据保存在本地，也可以保存在远程服务器上。</p><ul><li>docker volume create xxx创建存储卷</li><li>docker volume ls查看存储卷</li><li>docker volume inspect xxx查看存储卷信息</li><li>docker volume rm xxx删除存储卷</li></ul><h2 id="Docker修改日志大小"><a href="#Docker修改日志大小" class="headerlink" title="Docker修改日志大小"></a>Docker修改日志大小</h2><p>docker默认日志大小为100M，可以通过修改配置文件来修改日志大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;<br>  &quot;log-driver&quot;: &quot;json-file&quot;,<br>  &quot;log-opts&quot;: &#123;<br>    &quot;max-size&quot;: &quot;10m&quot;,<br>    &quot;max-file&quot;: &quot;3&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB学习笔记</title>
      <link href="/2023/03/05/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/05/MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>NoSql，先研究用来存图片</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>MongoDB属于Nosql，将数据存储为文档。<br>它有诸多概念：数据库，集合，文档，字段。 </p><blockquote><p>集合类似RDBMS（关系数据库）的表，但没有固定的结构，可以插入不同格式和类型数据<br>文档类似RDBMS的键值对。</p></blockquote><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><ul><li>use xxx使用&#x2F;创建某个数据库</li><li>show dbs展示数据库</li><li>db.dropDatabase()删库跑路</li></ul><h2 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h2><ul><li>db.creatCollections(“name”, options可选)创建集合</li><li>show collections展示集合</li><li>db.xxxx.drop()删除某个集合</li></ul><h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><ul><li>db.xxxx.insert()插入一个文档，也可以直接插入一个变量</li><li>db.xxxx.insertOne()插入一个新文档</li><li>db.xxxx.insertMany([], {ordered: true按顺序插入})插入多个文档</li><li>db.xx.update(<query>,<update>)更新文档</li><li>db.xx.deletedMany(<query>)删除多个文档</li><li>db.xx.deleteOne(<query>)删除文档</li><li>db.xx.find(<query>)查询文档</li><li>.pretty()易读模式</li><li>.limit()限制数量</li><li>.skip()跳过多少个数据</li><li>.sort()排序</li><li>.createIndex()可以添加方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">查询的query:<br>&#123;&lt;key&gt;:&lt;value&gt;&#125;为相等<br>&#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125;小于<br>&#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;小于等于<br>&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;大于<br>&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125;大于等于<br>&#123;&lt;key&gt;:&#123;$ne:&lt;value&gt;&#125;&#125;不等于<br>&#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;,$or: [&#123;&lt;value&gt;&#125;,&#123;&lt;value&gt;&#125;]&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="聚合aggregate-复杂先🕊了"><a href="#聚合aggregate-复杂先🕊了" class="headerlink" title="聚合aggregate (复杂先🕊了)"></a>聚合aggregate (复杂先🕊了)</h2><p>aggregate([ 操作 ])<br><a href="https://www.runoob.com/mongodb/mongodb-aggregate.html">教程位置</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论坛的进出系统</title>
      <link href="/2022/11/05/%E8%AE%BA%E5%9D%9B%E7%9A%84%E8%BF%9B%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/11/05/%E8%AE%BA%E5%9D%9B%E7%9A%84%E8%BF%9B%E5%87%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>整体采用SaToken框架</p><span id="more"></span><p>写登录系统，需要处理以下问题:</p><ul><li>后端操作数据库</li><li>token的设置</li><li>后端异常拦截</li><li>前端登陆页面</li><li>前端request处理</li></ul><hr><blockquote><p>首先，我们先写后端操作数据库部分:</p></blockquote><p>我们采用DDD框架，将后端结构分为apis, application, domain, infrastructure四个分层。<br><br>先来写domain层部分: <br><br>在domain层(领域层)，建立领域实体类Account和相关映射。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//账号实体</span><br><span class="hljs-meta">@TableName(value = <span class="hljs-string">&quot;account&quot;</span>, autoResultMap = true)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">var</span> userId: String = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> userName: String = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> role: String = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> password: String = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> deleted: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AccountMapper</span>: <span class="hljs-type">BaseMapper</span>&lt;<span class="hljs-type">Account</span>&gt;<br></code></pre></td></tr></table></figure><p><em>这里一定记住mysql用_分开定义字段，而kotlin是用驼峰法定义字段。</em><br><br>在建立映射后，写领域服务AccountRepository:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//账号的仓库类，提供基本操作服务</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountRepository</span>(<span class="hljs-keyword">val</span> accountMapper: AccountMapper) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">selectAccountByName</span><span class="hljs-params">(userName: <span class="hljs-type">String</span>)</span></span>: Account? &#123;<br>        <span class="hljs-keyword">return</span> accountMapper.selectOne(<br>            QueryWrapper&lt;Account&gt;().eq(<span class="hljs-string">&quot;user_name&quot;</span>, userName)<br>        )<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">selectAccountById</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>)</span></span>: Account? &#123;<br>        <span class="hljs-keyword">return</span> accountMapper.selectOne(<br>            QueryWrapper&lt;Account&gt;().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId)<br>        )<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">insertAccount</span><span class="hljs-params">(account: <span class="hljs-type">Account</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> accountMapper.insert(account)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkingUserName</span><span class="hljs-params">(userName: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> accountMapper.exists(<br>            QueryWrapper&lt;Account&gt;().eq(<span class="hljs-string">&quot;user_name&quot;</span>, userName)<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里写了四个方法，用来登录时查询账号，登陆后查询账号，注册账号，查重用户名。<br><br>这样domain层部分就写好啦~</p><hr><blockquote><p>开始写后端异常处理器部分</p></blockquote><p>在后端处理时，发生异常后，向前端抛出，前端也进行处理，完成异常的显示。<br><br>后端异常拦截部分:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//全局异常拦截</span><br><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-meta">@ExceptionHandler</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handlerException</span><span class="hljs-params">(exception: <span class="hljs-type">Exception</span>)</span></span>: SaResult? &#123;<br>        <span class="hljs-keyword">if</span> ( exception <span class="hljs-keyword">is</span> NotLoginException ) &#123;<br>            <span class="hljs-keyword">return</span> SaResult.code(<span class="hljs-number">501</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> SaResult.error(exception.message)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>注意，默认返回code为500，不登录返回code为501，服务器寄了返回code为502</em><br><br>现在，前端Response:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">request</span>: <span class="hljs-title class_">RequestConfig</span> = &#123;<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">20000</span>,<br>  <span class="hljs-attr">errorConfig</span>: &#123;<br>    <span class="hljs-attr">errorHandler</span>: <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">//responseInterceptors捕捉不到</span><br>      <span class="hljs-comment">// @ts-ignore</span><br>      <span class="hljs-keyword">if</span> (error.<span class="hljs-property">code</span> === <span class="hljs-string">&#x27;ERR_BAD_RESPONSE&#x27;</span>) &#123;<br>        message.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;服务器寄了&#x27;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      message.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">message</span>);<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">responseInterceptors</span>: [<br>    <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// @ts-ignore</span><br>      <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-attr">data</span>: &#123; code, msg &#125;,<br>      &#125; = response;<br>      <span class="hljs-keyword">switch</span> (code) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(msg);<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">501</span>:<br>          message.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;未登录账号&#x27;</span>);<br>          history.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> response;<br>    &#125;,<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>errorHandler用来拦截异常，responseInterceptors来监视Response。<br><br><em>nginx的502报错直接发给errorHandler</em></p><hr><blockquote><p>现在，该写token部分了:</p></blockquote><p>我们采用SaToken框架，这个嘎嘎好用√<br><br>只要将SaTokenConfigure类暴露在容器中，就可以完成配置啦:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SaTokenConfigure</span>: <span class="hljs-type">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(registry: <span class="hljs-type">InterceptorRegistry</span>)</span></span> &#123;<br>        registry.addInterceptor(SaAnnotationInterceptor())<br>            .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们启动了注解功能，可以校验是否登录。<br></p><hr><blockquote><p>然后再来写application层(应用层)与apis(接口层):</p></blockquote><p>建立LoginService:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> accountRepository: AccountRepository<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">register</span><span class="hljs-params">(userName: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> timestamp = Instant.now()<br>        <span class="hljs-keyword">var</span> account = Account()<br>        account.userId = timestamp.toEpochMilli().toString() + (<span class="hljs-number">100.</span><span class="hljs-number">.999</span>).random().toString()<br>        account.userName = userName<br>        <span class="hljs-keyword">if</span> ( accountRepository.checkingUserName(userName) ) &#123;<br>            <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">&quot;用户名重复&quot;</span>)<br>        &#125;<br>        account.password = BCrypt.hashpw(password, BCrypt.gensalt())<br>        account.role = <span class="hljs-string">&quot;user&quot;</span><br>        account.deleted = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            accountRepository.insertAccount(account)<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">&quot;注册失败&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">login</span><span class="hljs-params">(userName: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">val</span> user = accountRepository.selectAccountByName(userName)<br>            ?: <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">&quot;未查找到该用户&quot;</span>)<br>        <span class="hljs-keyword">if</span> (BCrypt.checkpw(password, user.password)) &#123;<br>            StpUtil.login(user.userId)<br>            <span class="hljs-comment">//录入user的缓存</span><br>            StpUtil.getSession().<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;user&quot;</span>, user)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">&quot;密码错误&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">logout</span><span class="hljs-params">()</span></span> &#123;<br>        StpUtil.logout()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>先来说注册方法，我们采用<strong>时间戳来作id（因为没用户，时间戳就够了XD），然后查重用户名，重要的是<br>将前端发来的密码加密，采用BCrypt类提供的方法加密存入数据</strong>，最后将数据插入数据库就好啦。<br></li></ul><p>建立LoginController:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//提供进出系统的接口</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> loginService: LoginService<br><br>    <span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginReq</span>(<br>        <span class="hljs-keyword">var</span> userName: String,<br>        <span class="hljs-keyword">var</span> password: String<br>    )<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/register&quot;</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">signIn</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> req: <span class="hljs-type">LoginReq</span>)</span></span> &#123;<br>        loginService.register(req.userName, req.password)<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/login&quot;</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loginIn</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> req: <span class="hljs-type">LoginReq</span>)</span></span> &#123;<br>        loginService.login(req.userName, req.password)<br>    &#125;<br><br>    <span class="hljs-meta">@SaCheckLogin</span><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/logout&quot;</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loginOut</span><span class="hljs-params">()</span></span>: String &#123;<br>        loginService.logout()<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登出&quot;</span><br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/isLogin&quot;</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isLogin</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (loginService.isLogin()) <span class="hljs-string">&quot;在&quot;</span> <span class="hljs-keyword">else</span>  <span class="hljs-string">&quot;不在&quot;</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里提供四个api，注册，登录，退出，判断在线。接口层主要关注传来参数与交付给应用层，所以这里直接调用应用层就好啦<br></p><hr><p><em>咳咳，一页写不下前端页面部分了，就不写了XD，大致就是写个页面加服务就行啦!</em><br>这样比较简陋的论坛进出系统就写好了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论坛的前后端基本搭建与部署</title>
      <link href="/2022/10/25/%E8%AE%BA%E5%9D%9B%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/10/25/%E8%AE%BA%E5%9D%9B%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>准备工作：<br>搭建前后端，和完成自动部署至远程服务器</p><span id="more"></span><h2 id="1-前端部分"><a href="#1-前端部分" class="headerlink" title="1.前端部分"></a>1.前端部分</h2><p>使用umi框架快速搭建项目，由于之前经常使用React，所以本次选择<strong>AntDesign</strong>开发<br>可以简单分析下umi的文件树中主要文件:</p><ul><li>.husky用来自动部署服务器</li><li>.umirc.ts用来配置<strong>路由</strong></li><li>src <ul><li>services存放请求函数</li><li>pages存放网页</li><li>components存放公用组件</li><li>app.ts存放Layout全局组件<blockquote><p>所出现的错误<br><br>1.cygpath: command not found” when commiting to branch<br>将Git\usr\bin\cygpath.exe放到&lt;% HOME %&gt;\AppData\Local\GitHubDesktop\app-3.1.2\resources\app\git\usr\bin即可<br>分析Git使用resource的cygpath程序时，未找到而报错</p><p>2.husky - commit-msg hook exited with code 1 (error)<br>第一次commit的时候，使用git commit “fix: ····”即可解决</p></blockquote></li></ul></li></ul><hr><p>在搭建前端项目后，就可以上服务器部署啦!<br><br>大致思路为：<em>前端先生成部署文件，自己手动部署，用nginx做代理服务器</em><br><br>下列是我所配置的.conf内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">server &#123;<br>        listen 10086;<br>        server_name TroForum.com;<br>        root /home/ubuntu/projects/TroForum/;<br><br>        index index.html index.htm index.nginx-debian.html;<br>        location / &#123;<br><br>        &#125;<br></code></pre></td></tr></table></figure><p>nginx服务器监听10086端口，使用根目录文件为TroForum<br><br>这样就完成项目的前端基础搭建与部署啦</p><h2 id="2-后端部分"><a href="#2-后端部分" class="headerlink" title="2.后端部分"></a>2.后端部分</h2><p>采用<strong>kotlin+Gradle+SpringBoot</strong>进行开发，因为kotlin与java使用的JVM一样，就不用再配置其他环境了<br><br>可以去Spring initializr自动生成<br>首先我们配置Gradle:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">plugins &#123;<br>id(&quot;org.springframework.boot&quot;) version &quot;2.7.5&quot;<br>id(&quot;io.spring.dependency-management&quot;) version &quot;1.0.15.RELEASE&quot;<br>kotlin(&quot;jvm&quot;) version &quot;1.6.21&quot;<br>kotlin(&quot;plugin.spring&quot;) version &quot;1.6.21&quot;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>配置插件，jvm,spring,springBoot框架这些都配上</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">group = &quot;com.example&quot;<br>version = &quot;0.0.1-SNAPSHOT&quot;<br>java.sourceCompatibility = JavaVersion.VERSION_1_8<br><br>repositories &#123;<br>    mavenCentral()<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>表明模块与版本，和java使用版本，和使用mavenCentral()为使用的配置仓库</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">dependencies &#123;<br>    implementation(&quot;org.springframework.boot:spring-boot-starter-web&quot;)<br>implementation(&quot;org.jetbrains.kotlin:kotlin-reflect&quot;)<br>implementation(&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot;)<br>testImplementation(&quot;org.springframework.boot:spring-boot-starter-test&quot;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>配置依赖，依赖可以在 <a href="https://mvnrepository.com/">mvnrepository.com</a> 查找</p></blockquote><p>配置好后即可构建项目啦，<del>成功就成功了</del> <br><br>构建项目好后就可以写配置文件了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">server:<br>    port: 8080<br>    servlet:<br>        context-path: /api<br></code></pre></td></tr></table></figure><p>port表示端口, context-path用来nginx分发</p><blockquote><p>接下来配置nginx</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">location /api &#123;<br>                proxy_pass http://127.0.0.1:8080;<br>                proxy_set_header X-Forwarded-Proto $scheme;<br>                proxy_set_header Host $http_host;<br>                proxy_set_header X-Real-IP $remote_addr;<br>        &#125;<br></code></pre></td></tr></table></figure><hr><p>接下来就可以部署啦!<br>跟前端一样，先手动部署，用nohup指令<br><br>这样就完成后端的构建与部署啦~</p><h2 id="3-数据库部分"><a href="#3-数据库部分" class="headerlink" title="3.数据库部分"></a>3.数据库部分</h2><p>大致流程：<br>在创建数据库后，进入数据库，把user中目标账号的host改为%，该账号即可面向所有ip连接，<br>后再将配置信息中bind_address改为0.0.0.0即可</p><p>在gradle的依赖里添加:</p><ul><li>spring-boot-starter-jdbc</li><li>mysql-connector-java</li><li>mybatis-plus-boot-starter<br>在配置文件里添加一下信息<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">spring:<br>  datasource:<br>    url: jdbc:mysql://XXXXXXXX:3306/TroForum?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;serverTimezone=GMT%2B8<br>    username: XXX<br>    password: XXXXXX<br>    driver-class-name: com.mysql.jdbc.Driver<br></code></pre></td></tr></table></figure>这样数据库部分也好啦，就可以开始写项目啦!</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习python的笔记本2</title>
      <link href="/2022/10/12/%E5%AD%A6%E4%B9%A0python%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC2/"/>
      <url>/2022/10/12/%E5%AD%A6%E4%B9%A0python%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>包含面向对象编程，面向对象高级编程</p></blockquote><span id="more"></span><h2 id="1-面向对象编程"><a href="#1-面向对象编程" class="headerlink" title="1.面向对象编程"></a>1.面向对象编程</h2><ul><li>使用class定义类，__init__为构造函数，self表示，用__开头标记为私有变量<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b</span>):<br>        self.__name = a<br>        self.__sex = b<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_all</span>():<br>        <span class="hljs-built_in">print</span>(__name, __sex)<br></code></pre></td></tr></table></figure></li><li>继承，class a(b)，a继承b，同时所有类继承object</li><li>动态语言，拥有相应类型的方法，就可以被看作相应类型</li><li>获取对象信息，方法有：dir(列出全部信息),isinstance(判断什么类型)</li></ul><h2 id="2-面向对象高级编程"><a href="#2-面向对象高级编程" class="headerlink" title="2.面向对象高级编程"></a>2.面向对象高级编程</h2><ul><li>__slots__可以限制对象动态绑定属性</li><li>@property装饰器，把一个方法变成属性调用，可以监控相关属性，类似<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">birth</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._birth<br><br><span class="hljs-meta">    @birth.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">birth</span>(<span class="hljs-params">self, value</span>):<br>        self._birth = value<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2015</span> - self._birth<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-异常处理、内建模块"><a href="#3-异常处理、内建模块" class="headerlink" title="3.异常处理、内建模块"></a>3.异常处理、内建模块</h2><ul><li>标准try expect finally处理异常，通过raise抛出异常Error</li><li>内建模块有多种，根据需求来import</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习python的笔记本1</title>
      <link href="/2022/10/08/%E5%AD%A6%E4%B9%A0python%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC1/"/>
      <url>/2022/10/08/%E5%AD%A6%E4%B9%A0python%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因之前学习过部分语言，所以就光说些不同的大方面啦<br>包括基础语法，函数，高级特性，高级函数，模块</p></blockquote><span id="more"></span><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>python是解释型语言，在执行时一行一行翻译成CPU能看懂的语言。<br>python的解释器有多种，也可以在不同平台相应解释器下运行。</p><h2 id="2-基础"><a href="#2-基础" class="headerlink" title="2.基础"></a>2.基础</h2><ul><li>Python采用<strong>Tab来区分代码块</strong>，相当于{}，记住<strong>Tab!&#x3D;4个空格</strong>。</li><li>基础数据类型有整数（无限大），浮点数（无限大），字符串，布尔值，空值，变量。</li><li>list[],是可变的。tuple()，是不变的。</li><li><strong>dic为{a:1}进行字典查询, set为set([])作为集合存放元素，创建应填写list类型</strong></li><li>条件判断:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> <span class="hljs-literal">True</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nihao%s&quot;</span> % a)<br><span class="hljs-keyword">elif</span> a == <span class="hljs-number">1</span>:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你好&quot;</span>)<br></code></pre></td></tr></table></figure></li><li>循环:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">//forin循环<br><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> b:<br>    <span class="hljs-built_in">print</span>(a)<br>//<span class="hljs-keyword">while</span>循环<br><span class="hljs-keyword">while</span> Ture:<br>    <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><ul><li>使用def定义函数，如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Hello_World</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你好&quot;</span>)<br></code></pre></td></tr></table></figure></li><li>pass表示空函数，可以表示暂时没想好写什么的内容</li><li>*可以把list的数值拆分为多个参数</li><li>函数传入的参数类型：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">c, d</span>): //顺序参数<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">c, d=[]</span>): //默认参数，只有第一次才会运行<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">*c</span>): //可变参数，传入<span class="hljs-built_in">tuple</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">**c</span>): //关键字参数，传入<span class="hljs-built_in">dict</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">a, *, d</span>): //在*之后，d为关键字传入a(<span class="hljs-number">1</span>, d=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-高级特性"><a href="#4-高级特性" class="headerlink" title="4.高级特性"></a>4.高级特性</h2><ul><li><p>切片: [x:y]，list切出x到y的list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">L[:<span class="hljs-number">10</span>]前<span class="hljs-number">10</span>个<br>L[:<span class="hljs-number">10</span>:<span class="hljs-number">2</span>]前<span class="hljs-number">10</span>个，隔两个取一次<br>L[-<span class="hljs-number">10</span>:]后<span class="hljs-number">10</span>个<br>L[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]第一个到倒数第一个<br></code></pre></td></tr></table></figure></li><li><p>列表生成式: [x for ····]，生成元素为x的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">[x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br>结果为[<span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">36</span>, <span class="hljs-number">64</span>, <span class="hljs-number">100</span>]<br>[m + n <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;ABC&#x27;</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;XYZ&#x27;</span>]<br>结果为[<span class="hljs-string">&#x27;AX&#x27;</span>, <span class="hljs-string">&#x27;AY&#x27;</span>, <span class="hljs-string">&#x27;AZ&#x27;</span>, <span class="hljs-string">&#x27;BX&#x27;</span>, <span class="hljs-string">&#x27;BY&#x27;</span>, <span class="hljs-string">&#x27;BZ&#x27;</span>, <span class="hljs-string">&#x27;CX&#x27;</span>, <span class="hljs-string">&#x27;CY&#x27;</span>, <span class="hljs-string">&#x27;CZ&#x27;</span>]<br></code></pre></td></tr></table></figure></li><li><p>生成器: (x for ····)，不生成列表，生成一个generator，占空间小，自动计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">g = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> g<br>    <span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure></li><li><p>yield先攒参数，然后可返回迭代对象</p></li><li><p>yield from可以之间返回迭代对象</p></li></ul><h2 id="5-高级函数"><a href="#5-高级函数" class="headerlink" title="5.高级函数"></a>5.高级函数</h2><ul><li>map&#x2F;reduce,map(f, [])可以让f函数作用于[],reduce(f, [])可以累计作用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span> (x):<br>    <span class="hljs-keyword">return</span> x * x<br>r = <span class="hljs-built_in">map</span>(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p</span> (x, y):<br>    <span class="hljs-keyword">return</span> x * y<br>k = reduce(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>[<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure></li><li>filter(b, [])，传入判断是否去留的函数与列表</li><li><strong>闭包</strong>:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">*args</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>():<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(*args)<br>    <span class="hljs-keyword">return</span> a<br>    <br>    <br>k = f(<span class="hljs-number">1</span>)<br>k()<br></code></pre></td></tr></table></figure>闭包就是将数据暂时存储到函数中，需要时候再调用即可</li><li>匿名函数:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> x(参数): x * x(返回值) <br></code></pre></td></tr></table></figure>匿名函数不具有函数名，可以随时调用，但只能有一个表达式</li></ul><h2 id="6-模块"><a href="#6-模块" class="headerlink" title="6.模块"></a>6.模块</h2><p>pip 可以安装其他模块，用import引用，类似包安装器</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
